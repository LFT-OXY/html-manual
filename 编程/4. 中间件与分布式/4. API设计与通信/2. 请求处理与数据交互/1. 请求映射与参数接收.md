
# 一. 简单参数接收

我们看到，在controller中，需要接收前端传递的请求参数。 那接下来，我们就先来看看在服务器端的Controller程序中，如何获取这类简单参数。 具体的方案有如下三种：

- **方案一：通过原始的** **`HttpServletRequest`** **对象获取请求参数**
    

```Java
/**
* 根据ID删除部门 - 简单参数接收: 方式一 (HttpServletRequest)
*/
@DeleteMapping("/depts")
public Result delete(HttpServletRequest request){
    String idStr = request.getParameter("id");
    int id = Integer.parseInt(idStr);
    
    System.out.println("根据ID删除部门: " + id);
    return Result.success();
}
```

这种方案实现较为繁琐，而且还需要进行手动类型转换。**【项目开发很少用】**

  

- **方案二：通过Spring提供的** **`@RequestParam`** **注解，将请求参数绑定给方法形参**
    

```Java
@DeleteMapping("/depts")
public Result delete(@RequestParam("id") Integer deptId){
    System.out.println("根据ID删除部门: " + deptId);
    return Result.success();
}
```

`@RequestParam` 注解的value属性，需要与前端传递的参数名保持一致 。

@RequestParam注解required属性默认为true，代表该参数必须传递，如果不传递将报错。 如果参数可选，可以将属性设置为false。

  

- **方案三：如果请求参数名与形参变量名相同，直接定义方法形参即可接收。（省略@RequestParam）**
    

```Java
@DeleteMapping("/depts")
public Result delete(Integer id){
    System.out.println("根据ID删除部门: " + deptId);
    return Result.success();
}
```

对于以上的这三种方案呢，我们**推荐第三种方案**。

## 代码实现

**1). Controller层**

在 `DeptMapper` 中，增加 `delete` 方法，代码实现如下：

```Java
/**
 * 根据id删除部门 - delete http://localhost:8080/depts?id=1
 */
@DeleteMapping("/depts")
public Result delete(Integer id){
    System.out.println("根据id删除部门, id=" + id);
    deptService.deleteById(id);
    return Result.success();
}
```

  

**2). Service层**

在 `DeptService` 中，增加 `deleteById` 方法，代码实现如下：

```Java
/**
 * 根据id删除部门
 */
void deleteById(Integer id);
```

在 `DeptServiceImpl` 中，增加 `deleteById` 方法，代码实现如下：

```Java
public void deleteById(Integer id) {
    deptMapper.deleteById(id);
}
```

  

**3). Mapper层**

在 `DeptMapper` 中，增加 `deleteById` 方法，代码实现如下：

```Java
/**
 * 根据id删除部门
 */
@Delete("delete from dept where id = #{id}")
void deleteById(Integer id);
```

如果mapper接口方法形参只有一个普通类型的参数，`#{…}` 里面的属性名可以随便写，如：`#{id}`、`#{value}`。

对于 DML 语句来说，执行完毕，也是有返回值的，返回值代表的是增删改操作，影响的记录数，所以可以将执行 DML 语句的方法返回值设置为 Integer。 但是一般开发时，是不需要这个返回值的，所以也可以设置为void。




# 二. json参数接收

我们看到，在controller中，需要接收前端传递的请求参数。 那接下来，我们就先来看看在服务器端的Controller程序中，如何获取json格式的参数。

- JSON格式的参数，通常会使用一个实体对象进行接收 。
    
- 规则：JSON数据的键名与方法形参对象的属性名相同，并需要使用`@RequestBody`注解标识。
    

  
前端传递的请求参数格式为json，内容如下：`{"name":"研发部"}`。这里，我们可以通过一个对象来接收，只需要保证对象中有name属性即可。

![PixPin_2025-04-29_15-11-08.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/PixPin_2025-04-29_15-11-08.png)

## **代码实现**

**1). Controller层**

在`DeptController`中增加方法save，具体代码如下：

```Java
/**
 * 新增部门 - POST http://localhost:8080/depts   请求参数：{"name":"研发部"}
 */
@PostMapping("/depts")
public Result save(@RequestBody Dept dept){
    System.out.println("新增部门, dept=" + dept);
    deptService.save(dept);
    return Result.success();
}
```

  

**2). Service层**

在`DeptService`中增加接口方法save，具体代码如下：

```Java
/**
 * 新增部门
 */
void save(Dept dept);
```

在`DeptServiceImpl`中增加save方法，完成添加部门的操作，具体代码如下：

```Java
public void save(Dept dept) {
    //补全基础属性
    dept.setCreateTime(LocalDateTime.now());
    dept.setUpdateTime(LocalDateTime.now());
    //保存部门
    deptMapper.insert(dept);
}
```

  

**3). Mapper层**

```Java
/**
 * 保存部门
 */
@Insert("insert into dept(name,create_time,update_time) values(#{name},#{createTime},#{updateTime})")
void insert(Dept dept);
```

如果在mapper接口中，需要传递多个参数，可以把多个参数封装到一个对象中。 在SQL语句中获取参数的时候，`#{...}` 里面写的是对象的属性名【注意是属性名，不是表的字段名】。


# 三. 路径参数接收

`/depts/1`，`/depts/2` 这种在url中传递的参数，我们称之为**路径参数**。 那么如何接收这样的路径参数呢 ？

路径参数：通过请求URL直接传递参数，使用{…}来标识该路径参数，需要使用 **`@PathVariable`**获取路径参数。如下所示：

![PixPin_2025-04-29_15-13-22.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/PixPin_2025-04-29_15-13-22.png)

如果路径参数名与controller方法形参名称一致，`@PathVariable` 注解的value属性是可以省略的。

## 代码实现

**1). Controller层**

在 `DeptController` 中增加 `getById`方法，具体代码如下：

```Java
/**
 * 根据ID查询 - GET http://localhost:8080/depts/1
 */
@GetMapping("/depts/{id}")
public Result getById(@PathVariable Integer id){
    System.out.println("根据ID查询, id=" + id);
    Dept dept = deptService.getById(id);
    return Result.success(dept);
}
```

  

**2). Service层**

在 `DeptService` 中增加 `getById`方法，具体代码如下：

```Java
/**
 * 根据id查询部门
 */
Dept getById(Integer id);
```

在 `DeptServiceImpl` 中增加 `getById`方法，具体代码如下：

```Java
public Dept getById(Integer id) {
    return deptMapper.getById(id);
}
```

  

**3). Mapper层**

在 `DeptMapper` 中增加 `getById` 方法，具体代码如下：

```Java
/**
* 根据ID查询部门数据
*/
@Select("select id, name, create_time, update_time from dept where id = #{id}")
Dept getById(Integer id);
```



# 四. @RequestMapping

到此呢，关于基本的部门的增删改查功能，我们已经实现了。 我们会发现，我们在 `DeptController` 中所定义的方法，所有的请求路径，都是 `/depts` 开头的，只要操作的是部门数据，请求路径都是 `/depts` 开头。

那么这个时候，我们其实是可以把这个公共的路径 `/depts` 抽取到类上的，那在各个方法上，就可以省略了这个 `/depts` 路径。代码如下：

![PixPin_2025-04-29_15-14-17.png|525](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/PixPin_2025-04-29_15-14-17.png)

一个完整的请求路径，应该是类上的 @RequestMapping 的value属性 + 方法上的 @RequestMapping的value属性。


# 五. Controller接收参数 (List/Array 参数)

在 `EmpController` 中增加如下方法 `delete` ，来执行批量删除员工的操作。

**方式一：在Controller方法中通过数组来接收**

多个参数，默认可以将其封装到一个数组中，需要保证前端传递的参数名 与 方法形参名称保持一致。

```Java
/**
* 批量删除员工
*/
@DeleteMapping
public Result delete(Integer[] ids){
    log.info("批量删除部门: ids={} ", Arrays.asList(ids));
    return Result.success();
}
```

  

**方式二：在Controller方法中通过集合来接收**

也可以将其封装到一个List<Integer> 集合中，如果要将其封装到一个集合中，需要在集合前面加上 `@RequestParam` 注解。

```Java
/**
* 批量删除员工
*/
@DeleteMapping
public Result delete(@RequestParam List<Integer> ids){
    log.info("批量删除部门: ids={} ", ids);
    empService.deleteByIds(ids);
    return Result.success();
}
```

两种方式，选择其中一种就可以，我们一般推荐选择集合，因为基于集合操作其中的元素会更加方便。