# 数据结构-Array

## 一、为什么要先学数据结构

### 1. 什么是数据结构

> 什么是数据结构？
>
> 数据结构就是用来**存放数据的某种结构**，大家了解几个关键点，时间和空间的问题。
>
> 1. 大家追求的都是，存的数量多，读取速度快，新增速度也快。
> 2. 涉及，时间复杂度，空间复杂度。
>
> 数据结构长什么样子？
>
> 平时聊的数据结构，是在磁盘还是在内存中？聊内存。Mysql持久化的时候，才会去聊磁盘的数据结构。
>
> 内存的逻辑结构是平面是还是立体的？固态内存在物理上是立体的，但是逻辑上是平面的
>
> 
>
> 只有挨着存放和分开存放。所以，数据结构的核心，就是**数组**和**链表**。



大家大学学过很多数据结构，但是为什么我们只说有两种？所有后续的结构都是，基于数组和链表的变形体。



### 2. 目的

1. 从最基本的集合框架源码开始学习，知道怎么阅读源码，方便未来，扩展的并发知识，ConcurrentHashMap，CopyOnWriteArrayList这些底层代码的源码。

2. 作为算法入门，了解一些时间复杂度的概念。

3. 面试中可能会涉及到笔试或者机试，让你定义一个数据结构，来处理某些问题。



还需要一点前置知识：

1. 二进制运算：记住16进制怎么转2进制即可。二进制计算。
2. 位运算：底层源码，很多地方都用到了位运算（性能是最好的，计算机只有加法）。&、|、^异或、~ 非、>>、>>>不带符号右移、<<。



## 二、数据的内存布局

### 1. 数组下标为什么是从0开始？

关键词：偏移量。数组的空间是连续空间。

前置知识：Java八大基本数据类型。（复习） 1byte = 8 bit

后续扩展知识：缓存行+volatile关键字、JUC 内存结构IC原件（硬件知识为什么计算机进制是2^10^）。



| 基本数据类型（他们是没有类的） | 大小（byte） | 包装类（有类的可以new的） |
| ------------------------------ | ------------ | ------------------------- |
| byte                           | 1            | Byte                      |
| boolean                        | 1            | Boolean                   |
| short                          | 2            | Short                     |
| char                           | 2            | Character                 |
| int                            | 4            | Integer                   |
| float                          | 4            | Float                     |
| double                         | 8            | Double                    |
| long                           | 8            | Long                      |



![image-20250414155322965](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504141553101.png)

> 数组的开始位子，就是下标0对应的元素位子。  第一个元素就是数组的地址，**偏移量**是0，下标就是偏移量。
>
> 数组地址 + 下标*元素大小 = 元素的起始位子 
>
> arr[0]  ----> 底层先去找到数组地址，根据后面的0 * 元素大小，等于数据的起始位子。





![image-20250414155850862](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504141558002.png)





### 2. 数组为什么不能直接扩容？

下标越界。同时，数组定义后，长度不能变。

![image-20250414160332023](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504141603158.png)

原因：

1. 无法确定数组后面的空间，有没有被占用。其实可以确定数组后面的空间，有没有被其他对象占用（指针），性能的损坏，还比不上，我直接复制一个新的数组。
2. 数组的声明，必须指定长度的。数组的起始和终止的地址，都已经固定了。数组的地址变量已经赋值给arr变量。重新计算下标越界终止的地址，消耗也很大。
3. 自定义的一个对象，是数组类型，对象内部，是有一个区域，来存放数组的地址。（JUC中锁升级过程里面，OOP的时候，会给大家介绍）
4. 扩容的性能还不错，怎么扩容？Arrays.copyOf(oldArr, newLength); 返回一个新的数组。

```java
public class Main {
    public static void main(String[] args) {
       int[] arr = new int[4];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i*5;
        }
        for (int i : arr) {
            System.out.print(i + " ");
        }
        //在这个数组最后面添加一个20
        System.out.println();
        //下面这个代码最后执行的是什么? = 赋值运算,是优先级最低的。
        arr = Arrays.copyOf(arr,arr.length+1);
        arr[4] = 20;
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }
}
```

> 上面，复制新数组，有没有旧数组的数据？有。



### 3. 中间插入数据

add(int index,Object obj); 自定义数组中任意下标添加一个元素。

```java
import java.util.Arrays;

public class Main {
    Object[] arr;

    public Main(int length) {
        this.arr = new Object[length];
    }

    public Main() {
    }

    static int size = 0; //用来表示元素的个数
    public static void main(String[] args) {
        Main main = new Main(10);
        for (int i = 0; i < main.arr.length; i++) {
            main.arr[i] = i;
            size++;
        }
        System.out.println("初始数组：");

        for (Object i : main.arr) {
            System.out.print(i + ", ");
        }
        main.add(9,120);
        System.out.println("插入元素后的内容!");
        for (Object i : main.arr) {
            System.out.print(i + ", ");
        }
    }
    /**
     * 写ArrayList底层源码
     * 根据下标来新增数据, 需求，判断下标越界，同时，判断如果数据 放满了才扩容
     * ChangeLog : 1. 创建 (25/04/14/星期一 16:48 [马宇航]);
     * @param index 下标
     * @param o 对象
     * @return void
    */
    public void add(int index,Object o){
        //判断下标越界
        if(index < 0 || index >= arr.length){
            throw new IndexOutOfBoundsException("下标越界");
        }
        //判断是否放满, 如果放满就扩容
        if(size == arr.length){
            //扩容 ArrayList底层是扩容几倍?1.5倍  >>右移
            /*
                0001 0010  = 18  >> 1
              >>1                带符号右移
              ----------------
                0000 1001  = 9   所有1都往右移动1位
            */
            arr = Arrays.copyOf(arr,(arr.length>>1)+arr.length);
            //在某个下标插入想要的元素. 我不用for去玩
            //它有5个参数,同时它是native方法,底层是C语言写的,所以效率高
            /**
             * 1 src – the source array.  源数组
             * 2 srcPos – starting position in the source array. 想要插入的目标下标(起始位子)
             * 3 dest – the destination array.  目标数组
             * 从源数组--->目标数组
             * 4 destPos – starting position in the destination data . 目标数组的粘贴位置
             * 5 length – the number of array elements to be copied  复制的源数组的数量(起始位子开始计算)
             * 125是一套相关的参数,45是第二个整体参数.
            **/
            System.arraycopy(arr,index,arr,index+1,size-index);
            System.out.println("复制了目标数据到目标数组之后的效果:");//0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0,
            for (Object i : arr) {
                System.out.print(i + ", ");
            }
            arr[index] = o;
        }
    }
}
```

### 4. 排序算法(重点不是算法)

> 有了AI，排序代码很容易写。
>
> 毕业后遇到华为OD外包面试，百分之百会有算法机试，动态规划（递归问题）。
>
> 了解时间复杂度计算。
>
> 时间复杂度的$O(log n)$ 是怎么计算出来的？
>
> ```java
> int i = 1;
> while(i < n){  //n就是上面的logn的n  n  15
>     i = i * 2; //1 2 4 8 16
> }
> ```
>
> 2^n^  =  i   //n表示循环次数
>
> n = $log_2i $  无论是2还是10都不影响
>
> n = $log_{10}i$ = log i
>
> 具体时间复杂度计算方式：
>
> 1. 单一函数，只看循环次数最多的代码块，它就是整个函数的时间复杂度
> 2. 加法法则：函数内部所有时间复杂度相加，结果量级最大的时间复杂度
> 3. 乘法法则：递归和嵌套的时候，复杂度等于，内外层复杂度的 乘积





#### 1 冒泡排序

![冒泡排序](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202502081716628.gif)

原理：外层循环N次，内层循环一次。每次可以找到一个最大值(黄色部分）。

> 额外补充，位运算知识。
>
> 问题：在不使用第三个变量的情况下，交换两个变量的值。
>
> ```java
> /**
>  * @Author: 马宇航
>  * @Todo: TODO
>  * @DateTime: 25/04/15/星期二 11:18
>  * @Component: 成都蜗牛学苑
>  **/
> public class ExchangeTwo {
>     public static void main(String[] args) {
>         exchange(10,20);
>     }
>     public static void exchange(Integer a1, Integer a2) {
>         System.out.println("刚传入的时候的值a1 = "+a1+" ----- a2 = "+a2);
>         /*
>             1. 异或运算
>                 计算方式一: 相同为0, 不同为1
>                 计算方式二: 上下相加不进位
>               10 ^ 20
>               0000 1010  = 10  密钥
>               0001 0100  = 20  原文
>               ------------ ^
>               0001 1110  = 30  密文
>               0001 0100  = 20
>               ------------ ^
>               0000 1010  = 10  原文
>               当前这个没问题,但是我们接下来要看一个东西  异或特点: 互为密钥
>               10^30 = 20
>               20^30 = 10
>             2. 交换两个变量的值
>             3. 不使用第三方变量
>          */
>         a1 = a1 ^ a2; // a1 = 30 a2 = 20
>         a2 = a1 ^ a2; // 30 ^ 20 = 10  a2 = 10
>         a1 = a1 ^ a2; // 30 ^ 10 = 20  a1 = 20
>         System.out.println("交换后的值a1 = "+a1+" ----- a2 = "+a2);
>     }
> }
> ```

冒泡：

```java
public static void bubblingSorting(){
    //直接写一个冒泡排序 用异或方案
    Integer[] arr = {20,10,90,30,70,100,50,60,72,80,};
    for (int i = 0; i < arr.length; i++) {
        //arr.length-i-1 数据, 因为每次循环都会把最大的放到最后面, 所以每次循环就少一个
        for (int j = 0; j < arr.length-i-1; j++) {
            if(arr[j] > arr[j+1]){
                arr[j] = arr[j] ^ arr[j+1];
                arr[j+1] = arr[j] ^ arr[j+1];
                arr[j] = arr[j] ^ arr[j+1];
            }
        }
    }
    for (int i = 0; i < arr.length; i++) {
        System.out.println(arr[i]);
    }
}
```

时间复杂度，需要考虑的是∞的数据。一定需要一个 假的参数，作为唯一变量 int n。

![image-20250415114144011](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504151141195.png)

冒泡排序的总时间复杂度 与空间复杂度：

- 时间复杂度：O(n^2^)，n是数组的长度
- 空间复杂度：占用内存空间，O(1)，数组需要的空间，就是常数级别的。



> 延伸一句话，牺牲时间换空间。
>
> 算法追求，都是在空间和时间之间，去折中值。

#### 2. 选择排序（Selection Sort）

![选择排序](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202502081722950.gif)

- **原理**：在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
- **代码实现**：

```java
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        selectionSort(arr);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

#### 3. 插入排序（Insertion Sort）

![插入排序](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202502081722329.gif)

- **原理**：将未排序数据插入到已排序序列的合适位置。从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置后；重复步骤 2~5。
- **代码实现**：

```java
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }

    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6};
        insertionSort(arr);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

- **时间复杂度**：$O(n^2)$，但在数组基本有序时效率较高。
- **空间复杂度**：$O(1)$。

#### 4. 快速排序（Quick Sort 刷一下，记住)

![快排](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202502081728660.webp)

- **原理**：选择一个**基准值**，将数组分为两部分，使得左边部分的所有元素都小于基准值，右边部分的所有元素都大于基准值，然后分别对左右两部分递归地进行排序。
- 根据上图，来分析快排的逻辑，自己写。
- **代码实现**：

```java
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high); 
            quickSort(arr, low, pi - 1);  
            quickSort(arr, pi + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }

    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        int n = arr.length;
        quickSort(arr, 0, n - 1);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

- **时间复杂度**：平均情况下为 $O(n log n)$，最坏情况下为 $O(n^2)$。
- **空间复杂度**：平均情况下为 $O(log n)$，最坏情况下为 $O(n)$。

#### 5. 归并排序（Merge Sort）

![归并排序](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202502081731379.gif)

- **原理**：采用**分治法**，将数组分成两个子数组，分别对这两个子数组进行排序，然后将排好序的子数组合并成一个最终的有序数组。
- **代码实现**：

```java
public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    private static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] L = new int[n1];
        int[] R = new int[n2];
        for (int i = 0; i < n1; i++) {
            L[i] = arr[left + i];
        }
        for (int j = 0; j < n2; j++) {
            R[j] = arr[mid + 1 + j];
        }
        int i = 0, j = 0;
        int k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        int n = arr.length;
        mergeSort(arr, 0, n - 1);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

- **时间复杂度**：$O(n log n)$。
- **空间复杂度**：$O(n)$，主要用于合并过程中的临时数组。

#### 6. 计数排序（Counting Sort）

> 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在**额外开辟的数组空间中**。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

**算法描述** - 找出待排序的数组中最大和最小的元素； - 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； - 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； - 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

**动图演示**

![计数排序](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202502081733151.gif)



**代码实现**

```java
function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue + 1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;

    for (var i = 0; i < arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }

    for (var j = 0; j < bucketLen; j++) {
        while(bucket[j] > 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }

    return arr;
}
```

**算法分析** 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法



- **时间复杂度**：$O(n+k)$。
- **空间复杂度**：$O(n+k)$。



### 5. 深拷贝和浅拷贝

> 概念：
>
> 1. 深拷贝：数组中的所有元素，全部拷贝一份（基本类型还是引用类型）。
> 2. 浅拷贝：clone方法，
>    1. 基本类型：数组是新的，元素是新的。
>    2. 引用类型：数组是新的，元素是旧的。

![image-20250415141758500](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504151417770.png)

#### 5.1 基本数据类型clone

```java
//        1. 浅拷贝
        int[] arr = {1,2,3,4,5,6,7};
        int[] arr1 = arr.clone();
        //被克隆的新数组内部数据发生变化影响我们的旧数组不
        arr1[0] = 100;
        for (int i : arr) {
            System.out.println("旧数据:"+i);
        }
        for (int i : arr1) {
            System.out.println("新数据:"+i);
        }
```

#### 5.2 引用数据类型的clone

1. String: 这里会出现不一样的结果？

   ```java
   //2. 浅拷贝
           String [] arr = {"1","2","3","4","5","6","7"};
           String [] arr1 = arr.clone();
           arr1[0] = "100";
           for (String i : arr) {
               System.out.println("旧数据:"+i); // 1 2 3 4
           }
           for (String i : arr1) {
               System.out.println("新数据:"+i);// 100 2 3 4
           }
   ```

   ![image-20250415142552498](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504151425857.png)

2. **对象数组**浅拷贝还有用么？

   ```java
   /**
    * @Author: 马宇航
    * @Todo: TODO
    * @DateTime: 25/04/15/星期二 14:08
    * @Component: 成都蜗牛学苑
    **/
   public class CloneDemo {
       public static void main(String[] args) {
           User[] users = new User[2];
           User user = new User("张三", 18);
           User user1 = new User("李四", 20);
           users[0] = user;
           users[1] = user1;
           User[] newusers = users.clone();
           //修改新数组对象的内部的值
           newusers[0].name = "王五";
           newusers[0].age = 22;
           System.out.println("原数组的内容:"+users[0]+"---"+users[1]);
           System.out.println("新数组的内容:"+newusers[0]+"---"+newusers[1]);
       }
   }
   class User{
       String name;
       int age;
       public User(String name, int age) {
           this.name = name;
           this.age = age;
       }
       @Override
       public String toString() {
           return "User{" +
                   "name='" + name + '\'' +
                   ", age=" + age +
                   '}';
       }
   }
   ```

   ![image-20250415143540770](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504151435097.png)

#### 5.3 深拷贝 不用讲

> 数组的内部，在引用类型下，都存储的是地址。
>
> 深拷贝，就必须让新旧数组内部，指向的地址是不一样的，但是数据内容一样。
>
> Arrays.copyOf()是深拷贝还是浅拷贝？浅拷贝。

![image-20250415143940970](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504151441133.png)

## 三、可以用数组实现的数据结构

> 队列Queue，栈Stack

### 1. 栈（JVM）

> 破冰，先了解点名词。
>
> 线程栈：每一个会话，都会生成对应的一个线程私有空间（栈区）
>
> 栈帧：简单来说就是方法。

![image-20250415151630434](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504151516745.png)

### 2. 自定义栈结构

> 我们可以用数组来实现栈，也可以用链表。
>
> 思路：
>
> 1. 定义个数组（长度）
> 2. top指针，永远指向栈顶，但是-1则表示空。



```java
/**
 * @Author: 马宇航
 * @Todo: 泛型, 泛型的好处, 就是在编译的时候就会检查类型, 避免了类型转换的错误
 * 泛型擦除: 泛型在编译的时候会被擦除, 所以在运行的时候, 是没有泛型的
 * @DateTime: 25/04/15/星期二 15:17
 * @Component: 成都蜗牛学苑
 **/
public class MyStack<E> {
    E[] arr; //存放数据的
    int top = -1; //-1 表示初始的指针位子

    public MyStack(int length) {
        this.arr = (E[]) new Object[length];
    }

    public MyStack() {
        this.arr = (E[]) new Object[10];
    }
    //一旦看见push和pop方法,表明就是有栈的特性
    //压栈
    public void push(E e) {
        //判断是否放满, 如果放满就扩容
        if (top == arr.length - 1) {
            throw new StackOverflowError();
        }
        arr[++top] = e;
    }
    //弹栈
    public E pop() {
        if (top == -1) {
            throw new RuntimeException("栈空");
        }
        return arr[top--];
    }
    //查看栈顶元素
    public E peek() {
        if (top == -1) {
            throw new RuntimeException("栈空");
        }
        return arr[top];
    }

    public static void main(String[] args) {
        MyStack<String> stringMyStack = new MyStack<>();
        stringMyStack.push("a");
        stringMyStack.push("b");
        stringMyStack.push("c");
        stringMyStack.push("d");
        stringMyStack.push("e");
        stringMyStack.push("f");
        System.out.println(stringMyStack.peek());
        System.out.println(stringMyStack.pop());
        System.out.println(stringMyStack.pop());
        stringMyStack.push("g");

        System.out.println(stringMyStack.peek());
    }
}
```

### 3. 需求

> 洗脚城，里面有很多服务员，轮训排好队，一个一个安排。
>
> ABCDEFG ---> ABCDEFG  可以用栈来实现。



## 四、ArrayList底层源码

> 教怎么养鱼，而不是怎么捕鱼。
>
> 这个看的思路，和其他的框架源码的思路，都差不多。



### 1. AI询问的面试题

- [ ] 请说明 `ArrayList` 在 Java 集合框架中的位置及作用。
- [ ] `ArrayList` 能存储不同类型的元素吗？为什么？
- [ ] 对比 `ArrayList` 和普通数组，它们的优缺点分别是什么？

- [ ] 为什么说 `ArrayList` 是非线程安全的，举例说明可能出现的问题。
- [ ] 除了 `Vector`、`Collections.synchronizedList` 和 `CopyOnWriteArrayList`，还有其他保证 `ArrayList` 线程安全的方式吗？
- [ ] 在高并发场景下，`CopyOnWriteArrayList` 替代 `ArrayList` 有哪些优势和不足？

- [ ] `ArrayList` 初始化时如果不指定容量，默认容量是多少，这个默认值是如何确定的？
- [ ] 当向 `ArrayList` 中频繁添加元素时，扩容操作会带来哪些性能问题？Arrays.copyOf()
- [ ] 请描述 `ArrayList` 中删除元素时，底层数组是如何处理的。

- [ ] 如何在 `ArrayList` 的指定位置插入元素，插入操作的时间复杂度是多少？
- [ ] 若要对 `ArrayList` 中的元素进行排序，有哪些方法可以实现？
- [ ] 怎样高效地删除 `ArrayList` 中**所有满足特定条件**的元素？二分查找法，找到所有的index在直接删。

- [ ] 对比 `ArrayList` 和 `LinkedList`，在不同操作（如随机访问、插入删除）下的性能表现如何？
- [ ] 与 `HashSet` 相比，`ArrayList` 在存储元素上有什么不同？
- [ ] `ArrayList` 和 `TreeSet` 在元素排序和存储方面有哪些差异？ 



### 2. 看（通用框架）源码的方式

1. 先看继承关系 （经验，数据结构的经验），经验看类名（框架类名一定是有迹可循Array，Linked，LinkedHash，Hash）
   1. List、Map、Set等，都是不同的数据结构特性。
   2. List 单列结构
   3. Map 双列结构
   4. Set 单列去重无序（为什么是无序）结构
2. 看构造方法，了解数据真实结构，实例化方案。
3. 看属性，稍微记住下名字就行
4. 核心：CRUD.

> 看源码最重要的东西：胆子要大，放心去猜。

#### 2.1 继承关系

![image-20250415162236318](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504151622631.png)

> 通过上诉继承关系，重点在于，**Iterable**，表示允许迭代，支持迭代器，那就有快速失败！！
>
> 不用迭代器，会有问题么？



```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
    //通过这个能看出什么内容？
    Cloneable和Iterable 接口比较重要。
    AbstractList类的内，有很多已经实现了的方法。
```



#### 2.2 构造方法

```java
 public ArrayList() {
     //默认无参，用得最多，new出来的时候，是个空数组！！！！！
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```

> 这个是最有用的！！！
>
> 默认new 空数组啊。没有容量的。
>
> 有什么意义？很多时候，只是new，而没数据add。
>
> 面试题：
>
> 1. 当你new ArrayList会发生什么？
> 2. 当你new完后，add后会发生什么？怎么进行扩容的？
> 3. 当你new完后，扩容3次后，容量变成多少？ 0-->10 --->15  --->22（溢出丢失） 
>    1. 小数怎么用二进制表示？

#### 2.3 属性（有个印象就ok）

```java
//默认容量
private static final int DEFAULT_CAPACITY = 10;
//空元素数组
private static final Object[] EMPTY_ELEMENTDATA = {};
//默认空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
//正儿八经存放数据的地方
//transient 不参与序列化！不参与序列化，那序列化后的数据是什么？
transient Object[] elementData; // non-private to simplify nested class access
//元素个数：拿来干嘛？后面看源码，注意size属性。
private int size;
//用来干嘛？Itr有关
protected transient int modCount = 0;
```

延伸：序列化内容？只包含部分属性，不包含**transient和static**的属性。

#### 2.4 CRUD 先看新增

##### 1. 新增 add(E e)

```java
//elementData 全局变量elementData
//s 就是全局变量的size
private void add(E e, Object[] elementData, int s) {
    //第一次新增， 0 == 0  直接扩容
    //第11次，size=10，length=10
    if (s == elementData.length)
        //if没有大括号，有效只有1行
        elementData = grow();
    //s = 10，下标10
    elementData[s] = e;
    //全局size属性+1
    size = s + 1;
}
```

第一个关键点：grow() 扩容方法

```java
//minCapacity = size + 1  第一次 size是0
private Object[] grow(int minCapacity) {
    	//旧数组长度
        int oldCapacity = elementData.length;
    	
        if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            int newCapacity = ArraysSupport.newLength(oldCapacity,
                    minCapacity - oldCapacity, /* minimum growth */
                    oldCapacity >> 1           /* preferred growth */);
            return elementData = Arrays.copyOf(elementData, newCapacity);
        } else {
            //第一次只会进入这里 Math.max(10,1) -->10
            return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
        }
    }
```

后续，已经扩容到 数组长度10。

添加第11个元素 才会进入grow方法。

```java
//minCapacity = size + 1 = 11  第11次 size是10
private Object[] grow(int minCapacity) {
    	//旧数组长度 10
        int oldCapacity = elementData.length;
        if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            //newCapacity = 15
            int newCapacity = ArraysSupport.newLength(oldCapacity,
                    minCapacity - oldCapacity, /* minimum growth */
                    oldCapacity >> 1           /* preferred growth */);
            
            
            //扩容 10 --> 15
            /*
            15扩容
            0000 1111 >> 1 = 0000 0111 = 7
            oldCapacity + oldCapacity>>1 = 15 + 7 =22
            */
            return elementData = Arrays.copyOf(elementData, newCapacity);
        } 
    }
```

jdk17的： ArraysSupport.newLength(）

```java
//oldLength = 10, minGrowth = 11 - 10 ,prefGrowth=oldCapacity >> 1 = 5
public static int newLength(int oldLength, int minGrowth, int prefGrowth) {
    //prefLength =  10 + 5
    int prefLength = oldLength + Math.max(minGrowth, prefGrowth); 
    if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {
        //return 15;
        return prefLength;
    } else {
        //下面不重要了，基本遇不到
        return hugeLength(oldLength, minGrowth);
    }
}
```

##### 2. 新增 add(int index, E e)

```java
public void add(int index, E element) {
    //不看你猜
    rangeCheckForAdd(index);
    modCount++;
    final int s;
    Object[] elementData;
    //JDK17可以赋值
    if ((s = size) == (elementData = this.elementData).length)
        //扩容
        elementData = grow();
    //关键点，眼熟
    System.arraycopy(elementData, index,
                     elementData, index + 1,
                     s - index);
    elementData[index] = element;
    size = s + 1;
}
```

##### 3. 删除与对象删除（过于简单）

索引删

```java
private void fastRemove(Object[] es, int i) {
    //删除也是 ++ ，表示修改成操作次数
    modCount++;
    final int newSize;
    
    if ((newSize = size - 1) > i)
        //往前覆盖
        System.arraycopy(es, i + 1, es, i, newSize - i);
    //末尾置空
    es[size = newSize] = null;
}
```

对象删：

```java
public boolean remove(Object o) {
    final Object[] es = elementData;
    final int size = this.size;
    int i = 0;
    //flag标记，表示for循环跳出后到这里，
    found: {
        //表明，数组可以存放null值
        if (o == null) {
            for (; i < size; i++)
                if (es[i] == null)
                    break found;
        } else {
            //i就是索引
            for (; i < size; i++)
                if (o.equals(es[i]))
                    //直接结束循环。
                    break found;
        }
        //没命中 
        return false;
    }
    //快速删除 索引 数组地址值传入，i索引
    fastRemove(es, i);
    return true;
}
```

##### 4. 修改（自己补笔记）

##### 5. 查询（自己补笔记）



快速失败。
