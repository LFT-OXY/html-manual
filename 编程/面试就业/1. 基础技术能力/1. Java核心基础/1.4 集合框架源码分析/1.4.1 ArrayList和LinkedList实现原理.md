
# 一. 常见集合

主要涉及到的是 List 和 Map 相关的面试题，比较高频就是

- ArrayList
    
- LinkedList
    
- HashMap
    
- ConcurrentHashMap

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414183937779.png)



- ArrayList 底层实现是**数组**
    
- LinkedList 底层实现是**双向链表**
    
- HashMap 的底层实现使用了**众多数据结构**，包含了**数组、链表、散列表、红黑树等**
    

在这些集合之后，会讲解数据结构，知道了数据结构的特点之后，熟悉集合就更加简单了。在讲解数据结构之前，也会简单普及一下算法复杂度分析，就能够评判代码的好坏，也能更加深入去理解数据结构和集合。


# 二. List 相关面试题

## 1. 数组

### 1.1 数组概述

数组（Array）是一种用**连续的内存空间**存储**相同数据类型**数据的线性数据结构。

`int[] array = {22,33,88,66,55,25};`

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414200844147.png)

我们定义了这么一个数组之后，在内存的表示是这样的：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414200854579.png)


现在假如，我们通过 `arrar[1]`，想要获得下标为 1 这个元素，但是现在栈内存中指向的堆内存数组的首地址，它是如何获取下标为 1 这个数据的？

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414200905384.png)

### 1.2 寻址公式

为了方便大家理解，我们把数组的内存地址稍微改了一下，都改成了数字，如下图

![](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414200941469.png)

在数组在内存中查找元素的时候，是有一个寻址公式的，如下：

`arr[i] = baseAddress + i * dataTypeSize`

> BaseAddress：数组的首地址，目前是 10
> 
> DataTypeSize：代表数组中元素类型的大小，目前数组重存储的是 int 型的数据，dataTypeSize=4 个字节
> 
> Arr：指的是数组
> 
> I：指的是数组的下标

有了寻址公式以后，我们再来获取一下下标为 1 的元素，这个是原来的数组

`int[] array = {22,33,88,66,55,25};`

套入公式：

`array[1] =10 + i * 4 = 14`

获取到 14 这个地址，就能获取到下标为 1 的这个元素了。

### 1.3 操作数组的时间复杂度

#### 1.3.1 随机查询 (根据索引查询)

数组元素的访问是通过下标来访问的，计算机通过数组的**首地址**和**寻址公式**能够很快速的找到想要访问的元素

```Java
public int test01(int[] a,int i){
   return a[i];
   // a[i] = baseAddress + i \* dataSize
}
```

代码的执行次数并不会随着数组的数据规模大小变化而变化，是常数级的，所以查询数据操作的时间复杂度是 O (1)

#### 1.3.2 未知索引查询 O (n) 或 O (log 2 n)
    

情况一：查找数组内的元素，查找 55 号数据，遍历数组时间复杂度为 O (n)

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414201115728.png)

情况二：查找排序后数组内的元素，通过二分查找算法查找 55 号数据时间复杂度为 O (logn)

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414201131515.png)


#### 1.3.3 插入 O (n)

数组是一段连续的内存空间，因此为了保证数组的连续性会使得数组的插入和删除的效率变的很低。

假设数组的长度为 n，现在如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。如下图所示：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414201237762.png)

新增之后的数据变化，如下

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414201246776.png)

所以：

插入操作，最好情况下是 O (1) 的，最坏情况下是 O (n) 的，**平均情况下的时间复杂度是 O (n)**。

#### 1.3.4 删除 O (n)

同理可得：如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了，时间复杂度仍然是 O (n)。


## 2. ArrayList 源码分析

分析 ArrayList 源码主要从三个方面去翻阅：成员变量，构造函数，关键方法

> 以下源码都来源于 jdk 1.8

### 2.1 成员变量

 ![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414201337260.png)

_DEFAULT_CAPACITY_ = 10; 默认初始的容量**(CAPACITY)

_EMPTY_ELEMENTDATA_ = {}; 用于空实例的共享空数组实例

_DEFAULTCAPACITY_EMPTY_ELEMENTDATA_ = {}; 用于默认大小的空实例的共享空数组实例

Object[] elementData; 存储元素的数组缓冲区

Int size; ArrayList 的大小（它包含的元素数量）

### 2.2 构造方法

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414201400024.png)

- 第一个构造是带初始化容量的构造函数，可以按照指定的容量初始化数组
    
- 第二个是无参构造函数，默认创建一个空集合

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250414201415644.png)

- 将 collection 对象转换成数组，然后将数组的地址的赋给 elementData

### 2.3 ArrayList 源码分析

添加数据的流程

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415111603431.png)


**结论：**

- 底层数据结构
    

ArrayList 底层是用动态的数组实现的

- 初始容量
    

ArrayList 初始容量为 0，当第一次添加数据的时候才会初始化容量为 10

- 扩容逻辑
    

ArrayList 在进行扩容的时候是原来容量的 1.5 倍，每次扩容都需要拷贝数组

- 添加逻辑
    
    - 确保数组已使用长度（size）加 1 之后足够存下下一个数据
        
    - 计算数组的容量，如果当前数组已使用长度+1 后的大于当前的数组长度，则调用 grow 方法扩容（原来的 1.5 倍）
        
    - 确保新增的数据有地方存储之后，则将新元素添加到位于 size 的位置上。
        
    - 返回添加成功布尔值。


###   2.4 面试题-ArrayList list=new ArrayList (10) 中的 list 扩容几次

难易程度：☆☆☆

出现频率：☆☆

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415111909582.png)

参考回答：

该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容


### 2.5 面试题-如何实现数组和 List 之间的转换

> 难易程度：☆☆☆
> 
> 出现频率：☆☆

如下代码：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415112012972.png)


参考回答：

- 数组转 List ，使用 JDK 中 java. Util. Arrays 工具类的 asList 方法
    
- List 转数组，使用 List 的 toArray 方法。无参 toArray 方法返回 Object 数组，传入初始化长度的数组对象，返回该对象数组
    

面试官再问：

1，用 Arrays. AsList 转 List 后，如果修改了数组内容，list 受影响吗

2，List 用 toArray 转数组后，如果修改了 List 内容，数组受影响吗


![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415112027068.png)


> 数组转 List 受影响
> 
> List 转数组不受影响

再答：

1，用 Arrays. AsList 转 List 后，如果修改了数组内容，list 受影响吗

Arrays. AsList 转换 list 之后，如果修改了数组的内容，list 会受影响，因为它的底层使用的 Arrays 类中的一个内部类 ArrayList 来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址

2，List 用 toArray 转数组后，如果修改了 List 内容，数组受影响吗

List 用了 toArray 转数组后，如果修改了 list 内容，数组不会影响，当调用了 toArray 以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使 list 修改了以后，数组也不受影响


## 3. 链表

### 1. 单向链表

- 链表中的每一个元素称之为结点（Node）
    
- 物理存储单元上，非连续、非顺序的存储结构
    
- 单向链表：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114350057.png)

代码实现参考：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114405606.png)


链表中的某个节点为 B，B 的下一个节点为 C 表示： `B.next==C`

### 2. 单向链表时间复杂度分析

（1）查询操作

![](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114503644.png)

- 只有在查询头节点的时候不需要遍历链表，时间复杂度是 O (1)
    
- 查询其他结点需要遍历链表，时间复杂度是 O (n)
    

（2）插入和删除操作

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114520669.png)


- 只有在添加和删除头节点的时候不需要遍历链表，时间复杂度是 O (1)
    
- 添加或删除其他结点需要遍历链表找到对应节点后，才能完成新增或删除节点，时间复杂度是 O (n)

### 3. 双向链表

而双向链表，顾名思义，它支持两个方向

- 每个结点不止有一个后继指针 next 指向后面的结点
    
- 有一个前驱指针 prev 指向前面的结点
    

参考代码

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114630559.png)


![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114637843.png)

对比单链表：

- 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址
    
- 支持双向遍历，这样也带来了双向链表操作的灵活性

### 4. 双向链表时间复杂度分析

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114711140.png)


1）查询操作

- 查询头尾结点的时间复杂度是 O (1)
    
- 平均的查询时间复杂度是 O (n)
    
- 给定节点找前驱节点的时间复杂度为 O (1)
    

（2）增删操作

- 头尾结点增删的时间复杂度为 O (1)
    
- 其他部分结点增删的时间复杂度是 O (n)
    
- 给定节点增删的时间复杂度为 O (1)

### 5. 面试题-ArrayList 和 LinkedList 的区别是什么？

- 底层数据结构
    
    - ArrayList 是动态数组的数据结构实现
        
    - LinkedList 是双向链表的数据结构实现
        
- 操作数据效率
    
    - ArrayList 按照下标查询的时间复杂度 O (1)【内存是连续的，根据寻址公式】， LinkedList 不支持下标查询
        
    - 查找（未知索引）： ArrayList 需要遍历，链表也需要遍历，时间复杂度都是 O (n)
        
    - 新增和删除
        
        - ArrayList 尾部插入和删除，时间复杂度是 O (1)；其他部分增删需要挪动数组，时间复杂度是 O (n)
            
        - LinkedList 头尾节点增删时间复杂度是 O (1)，其他都需要遍历链表，时间复杂度是 O (n)
            
- 内存空间占用
    
    - ArrayList 底层是数组，内存连续，节省内存
        
    - LinkedList 是双向链表需要存储数据，和两个指针，更占用内存
        
- 线程安全
    
    - ArrayList 和 LinkedList 都不是线程安全的
        
    - 如果需要保证线程安全，有两种方案：
        
        - 在方法内使用，局部变量则是线程安全的
            
        - 使用线程安全的 ArrayList 和 LinkedList


# 三. 真实面试还原

## 1. Java 常见的集合类

```java
面试官：说一说Java提供的常见集合？（画一下集合结构图）

候选人：

嗯~~，好的。

在java中提供了两大类的集合框架，主要分为两类：

第一个是Collection 属于单列集合，第二个是Map 属于双列集合

- 在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。 在Set接口中有实现类HashSet和TreeSet。
    
- 在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap
```


## 2. List

```java
面试官：ArrayList底层是如何实现的？

候选人：

嗯~，我阅读过arraylist的源码，我主要说一下add方法吧

第一：确保数组已使用长度（size）加1之后足够存下下一个数据

第二：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）

第三：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。

第四：返回添加成功布尔值。

面试官：ArrayList list=new ArrayList(10)中的list扩容几次

候选人：

是new了一个ArrarList并且给了一个构造参数10，对吧？(问题一定要问清楚再答)

面试官：是的

候选人：

好的，在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。
```

```java
面试官：如何实现数组和List之间的转换

候选人：

嗯，这个在我们平时开发很常见

数组转list，可以使用jdk自动的一个工具类Arrays，里面有一个asList方法可以转换为数组

List 转数组，可以直接调用list中的toArray方法，需要给一个参数，指定数组的类型，需要指定数组的长度。

面试官：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗

候选人：

Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址

list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响
```

```java
面试官：ArrayList 和 LinkedList 的区别是什么？

候选人：

嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。

1，从操作数据效率来说

ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询

查找（未知索引）： ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)

新增和删除

- ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)
    
- LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)
    

2，从内存空间占用来说

ArrayList底层是数组，内存连续，节省内存

LinkedList 是双向链表需要存储数据，和两个指针，更占用内存

3，从线程安全来说，ArrayList和LinkedList都不是线程安全的

面试官：嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？

候选人：

嗯，是这样的，主要有两种解决方案：

第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。

第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代

ArrayList可以通过Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。

LinkedList 换成ConcurrentLinkedQueue来使用
```


# ArrayList的浅拷贝与深拷贝

## 浅拷贝 (Shallow Copy)

ArrayList提供的 `clone()` 方法实现的是浅拷贝：

```java
ArrayList<String> original = new ArrayList<>();
original.add("Java");
original.add("Spring");

ArrayList<String> shallowCopy = (ArrayList<String>) original.clone();
```

**浅拷贝的特点**：

1. 创建一个新的ArrayList对象
2. 复制原ArrayList的大小、容量和其他属性
3. 复制元素的引用，而不是元素本身
4. 适用于存储基本数据类型或不可变对象的情况

**重要面试点**：

- 当ArrayList中存储的是对象引用时，修改复制后集合中的对象会影响原集合中的对象
- 浅拷贝只复制了对象的引用，共享同一块堆内存

```java
ArrayList<Person> original = new ArrayList<>();
original.add(new Person("张三"));

ArrayList<Person> copy = (ArrayList<Person>) original.clone();
copy.get(0).setName("李四");  // 原集合中的人名也会变成"李四"
```

## 深拷贝 (Deep Copy)

Java中实现ArrayList的深拷贝需要手动实现：

```java
ArrayList<Person> deepCopy = new ArrayList<>(original.size());
for (Person person : original) {
    deepCopy.add(new Person(person));  // 假设Person有复制构造函数
}
```


**深拷贝的特点**：

1. 创建一个新的ArrayList对象
2. 复制原ArrayList的属性
3. 复制每个元素对象本身（递归复制）
4. 两个集合完全独立，互不影响

**实现深拷贝的方法**：

1. 遍历集合并复制每个元素
2. 使用序列化和反序列化（需要实现Serializable接口）

```java
public static <T> ArrayList<T> deepCopy(ArrayList<T> original) throws Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);
    oos.writeObject(original);
    
    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bis);
    return (ArrayList<T>) ois.readObject();
}
```

## 面试常见问题

1. **如何判断ArrayList需要浅拷贝还是深拷贝？**
    - 取决于集合中元素的性质和使用场景
    - 存储基本类型包装类/String等不可变对象时，浅拷贝足够
    - 存储自定义可变对象时，通常需要深拷贝
2. **ArrayList的clone()方法与构造函数拷贝的区别？**
```java
ArrayList<String> copy1 = (ArrayList<String>) original.clone();
ArrayList<String> copy2 = new ArrayList<>(original);
```

- - 两者都是浅拷贝
    - 性能上可能略有差异，但功能相同
- **如何高效实现大数据量ArrayList的深拷贝？**
    - 对于简单对象，手动循环复制通常更高效
    - 对于复杂对象，可以考虑使用JSON序列化/反序列化（如Jackson、Gson）
    - 可以实现自定义的复制策略，只复制需要的字段