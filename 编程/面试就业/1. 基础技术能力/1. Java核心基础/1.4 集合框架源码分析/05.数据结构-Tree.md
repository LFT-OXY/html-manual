

# 数据结构-Tree

## 一、常见树

![image-20250418113440769](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504181134859.png)

普通的树有哪些特点？

1.root根节点只有一个，它是作为树遍历的第一个头节点。

2.left通常称之为左子树（left和下面的分支），right通常称之为右子树

3.left节点，又是左边的叶子节点的根节点。

4.层高h通常决定了节点的数量n



### 1. 二叉树

![image-20250418113924555](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504181139641.png)

二叉树的特点：

只有左子节点和右子节点，它不一定平衡.  它只考虑只有里两个分支。子节点

**分支情况**(二叉树**不考虑**)：左（比根）小右比根）大

层高节点数n的计算：

如果是平衡的，左右的对称。

2^h^ - 1 = n

当h越高的时候， n节点数量就越多。$h = log_2^n$

 

如果要存放13亿人名，用链表和树 哪一个查询速度快？



2的31次方 = 21亿47483648

也就是说这棵树有多高？31层。最多也就比较查询31次就能找到对应的人。次。



> 层高越高，查询次数就越多。能否降低这个层高，来减少我们查询最多的次数？



### 2. 遍历方式

![image-20250418142750580](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504181427712.png)

先根遍历（根左右）：8，6，3，7，13，11，15

中根遍历（左根右）：3，6，7，8，11，13，15

后根遍历（左右根）：3，7，6，11，15，13，8

下列代码，手动拼接上图内容：



### 3. BST二叉搜索树

BST（Binary Search Tree）二叉搜索树（Binary Search Tree）是一种特殊的二叉树，它满足以下性质：对于树中的每个节点，其左子树中的所有节点的值都小于该根节点的值，其右子树中的所有节点的值都大于该根值。这种特性使得BST在查找、插入和删除操作中具有较高的效率。

> 特殊情况下，二叉搜索树，可能会退化成链表。	

![image-20250213170517789](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202502131705063.png)

```java
package com.woniuxy;


/**
 * @Author: 马宇航
 * @Todo: 二叉搜索树的开发
 * @DateTime: 25/04/18/星期五 11:49
 * @Component: 成都蜗牛学苑
 **/
public class MyBinaryTree {
    private TreeNode root;
    private int size;
    private class TreeNode {
        Integer data;
        TreeNode left;
        TreeNode right;

        public TreeNode(Integer data, TreeNode left, TreeNode right) {
            this.data = data;
            this.left = left;
            this.right = right;
        }
    }
    //插入
    public void add(Integer data) {
        if(root == null) {
            root = new TreeNode(data, null, null);
        }else {
            //从根节点开始查找
            TreeNode current = root;
            //如果当前节点非空(非nil叶子节点)
              //继续遍历 -- 递归 自己的方法调用自己
            current  = addRecursion(current, data);
//            System.out.println("插入成功"+current.data);
        }
    }
    //递归插入
    public TreeNode addRecursion(TreeNode current, Integer data) {
          //先比较大小
            if(current.data > data) {
                if(current.left == null) {
                    current.left = new TreeNode(data, null, null);
                    current = current.left;
                    return current;
                }else{
                    //左子树非空继续递归
                  return addRecursion(current.left, data);
                }
            }else if(current.data < data){
                if(current.right == null) {
                    current.right = new TreeNode(data, null, null);
                    current = current.right;
                    return current;
                }else {
                  return addRecursion(current.right, data);
                }
            }else{
                //相等
                return current;
            }
        }
    //遍历 先序遍历(先根遍历，先 根左右)
    public void preOrderTraversal(TreeNode node) {
        if(node == null) {
            return;
        }else {
            //先访问根节点
            System.out.println(node.data);
            //再访问左子树
            preOrderTraversal(node.left);
            //再访问右子树
            preOrderTraversal(node.right);
        }
    }
    //中序遍历 （中根遍历，先 左根右）
    public void inOrderTraversal(TreeNode node) {
        if(node == null) {
            return;
        }else {
            //先访问左子树
            inOrderTraversal(node.left);
            //再访问根节点
            System.out.println(node.data);
            //再访问右子树
            inOrderTraversal(node.right);
        }
    }
    //后续遍历 （后根遍历，先 左右根）
    public void postOrderTraversal(TreeNode node) {
        if(node == null) {
            return;
        }else {
            //先访问左子树
            postOrderTraversal(node.left);
            //再访问右子树
            postOrderTraversal(node.right);
            //再访问根节点
            System.out.println(node.data);
        }
    }

    public static void main(String[] args) {
        MyBinaryTree myBinaryTree = new MyBinaryTree();
        //8，13，6，11，3，7，15
        myBinaryTree.add(8);
        myBinaryTree.add(13);
        myBinaryTree.add(6);
        myBinaryTree.add(11);
        myBinaryTree.add(3);
        myBinaryTree.add(7);
        myBinaryTree.add(15);
        myBinaryTree.preOrderTraversal(myBinaryTree.root);
    }
}
```

### 4. AVL树（自平衡二叉搜索树）

比BST多了一个条件，自平衡机制，即左右子树的高度差**不超过1**。

AVL使用左旋右旋机制. 

https://www.cs.usfca.edu/~galles/visualization/AVLtree.html



### 5. 红黑树(重点)

![image-20250418154335876](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504181543990.png)







#### 红黑树5大基础理论

1. 顶层根节点一定是黑色
2. 父子两个节点不能都是红色
3. 默认根叶子节点一定是黑色，且为null （nil)

4. 从根节点开始，数到叶子节点路径上的黑色节点数量全部一致

5. 不是黑就是红，boolean修饰



所有插入的节点都是红色



#### 旋转和变色规则:

#### 平衡的操作方式：方言版

变色：
	触发条件：插入节点的父节点和叔叔节点，都是红色，才变色。
	操作：父和叔变黑，爷爷变红

旋转：

1.**大旋转**

触发条件：插入节点的父节点和爷爷节点在**一条直线**上。

​	1.1 **右旋**

​		判断条件：这条直线，往哪里倒，就往哪里旋转。

​		操作：父节点变根节点，爷爷变成右节点，送儿子（右旋送右儿子）

​		旋转后交换之前父和爷爷的颜色。

​	1.2 **左旋**

​		判断条件：这条直线，往哪里倒，就往哪里旋转。

​		操作: 父节点变根节点，爷爷变成左节点，送儿子（左旋送左儿子）

​		旋转后交换之前父和爷爷的颜色。

2.**小旋转** : 小旋转的目的是为了大旋转

触发条件，插入节点和父节点与爷爷节点不在一条直线上。

​	1.1 **右旋**

​		判断条件，插入节点和父节点这条直线往右倒，则为小右旋。

​		操作：插入节点变成父节点，父节点变成右子节点。

​	1.2 **左旋**

​		判断条件，插入节点和父节点这条直线往左倒，则为小左旋。

​		操作：插入节点变成父节点，父节点变成左子节点。

​		

### 6. HashMap的底层红黑树源代码

```java
static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,
                                      TreeNode<K,V> p) {
    TreeNode<K,V> r, pp, rl;
    if (p != null && (r = p.right) != null) {
        if ((rl = p.right = r.left) != null)
            rl.parent = p;
        if ((pp = r.parent = p.parent) == null)
            (root = r).red = false;
        else if (pp.left == p)
            pp.left = r;
        else
            pp.right = r;
        r.left = p;
        p.parent = r;
    }
    return root;
}

static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,
                                       TreeNode<K,V> p) {
    TreeNode<K,V> l, pp, lr;
    if (p != null && (l = p.left) != null) {
        if ((lr = p.left = l.right) != null)
            lr.parent = p;
        if ((pp = l.parent = p.parent) == null)
            (root = l).red = false;
        else if (pp.right == p)
            pp.right = l;
        else
            pp.left = l;
        l.right = p;
        p.parent = l;
    }
    return root;
}
```

