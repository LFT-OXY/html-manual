
# 一. HashMap 相关面试题

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114826527.png)


## 1. 二叉树

### 1.1 二叉树概述

二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

二叉树每个节点的左子树和右子树也分别满足二叉树的定义。

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415114946418.png)


Java 中有两个方式实现二叉树：数组存储，链式存储。

基于链式存储的树的节点可定义如下：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115003851.png)

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115011529.png)


### 1.2 二叉搜索树

在二叉树中，比较常见的二叉树有：

- 满二叉树
    
- 完全二叉树
    
- **二叉搜索树**
    
- **红黑树**
    

我们重点讲解二叉搜索树和红黑树

（1）二叉搜索树概述

二叉搜索树 (Binary Search Tree, BST) 又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型

二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值

![](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115045189.png)

（2）二叉搜索树-时间复杂度分析

实际上由于二叉查找树的形态各异，时间复杂度也不尽相同，我画了几棵树我们来看一下插入，查找，删除的时间复杂度

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115100608.png)

插入，查找，删除的时间复杂度**O (logn)**

  

极端情况下二叉搜索的时间复杂度

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115113300.png)


对于图中这种情况属于最坏的情况，二叉查找树已经退化成了链表，左右子树极度不平衡，此时查找的时间复杂度肯定是 O (n)。


### 1.3 红黑树

（1）概述

**红黑树（Red Black Tree）**：也是一种自平衡的二叉搜索树 (BST)，之前叫做平衡二叉 B 树（Symmetric Binary B-Tree）

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115145597.png)


（2）红黑树的特质

性质 1：节点要么是**红色**, 要么是**黑色**

性质 2：根节点是**黑色**

性质 3：叶子节点都是黑色的空节点

性质 4：红黑树中红色节点的子节点都是黑色

性质 5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点

**在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡**

  

（3）红黑树的复杂度

- 查找：
    
    - 红黑树也是一棵 BST（二叉搜索树）树，查找操作的时间复杂度为：O (log n)
        
- 添加：
    
    - 添加先要从根节点开始找到元素添加的位置，时间复杂度 O (log n)
        
    - 添加完成后涉及到复杂度为 O (1) 的旋转调整操作
        
    - 故整体复杂度为：O (log n)
        
- 删除：
    
    - 首先从根节点开始找到被删除元素的位置，时间复杂度 O (log n)
        
    - 删除完成后涉及到复杂度为 O (1) 的旋转调整操作
        
    - 故整体复杂度为：O (log n)



## 2. 散列表

在 HashMap 中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表

### 2.1 散列表（Hash Table）概述

散列表 (Hash Table) 又名哈希表/Hash 表，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性

举个例子：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115244055.png)


假设有 100 个人参加马拉松，编号是 1-100，如果要编程实现根据选手的编号迅速找到选手信息？

可以把选手信息存入数组中，选手编号就是数组的下标，数组的元素就是选手的信息。

当我们查询选手信息的时候，只需要根据选手的编号到数组中查询对应的元素就可以快速找到选手的信息，如下图：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115306272.png)


现在需求升级了：

假设有 100 个人参加马拉松，不采用 1-100 的自然数对选手进行编号，编号有一定的规则比如：2023 ZHBJ 001，其中 2023 代表年份，ZH 代表中国，BJ 代表北京，001 代表原来的编号，那此时的编号 2023 ZHBJ 001 不能直接作为数组的下标，此时应该如何实现呢？

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115319254.png)

我们目前是把选手的信息存入到数组中，不过选手的编号不能直接作为数组的下标，不过，可以把选手的选号进行转换，转换为数值就可以继续作为数组的下标了？

转换可以使用散列函数进行转换


### 2.2 散列函数和散列冲突

将键 (key) 映射为数组下标的函数叫做散列函数。可以表示为：hashValue = hash (key)

散列函数的基本要求：

- 散列函数计算得到的散列值必须是大于等于 0 的正整数，因为 hashValue 需要作为数组的下标。
    
- 如果 key 1==key 2，那么经过 hash 后得到的哈希值也必相同即：hash (key 1) == hash (key 2）
    
- **如果 key 1 != key 2，那么经过 hash 后得到的哈希值也必不相同即：hash (key 1) != hash (key 2)**
    

  

实际的情况下想找一个散列函数能够做到对于不同的 key 计算得到的散列值都不同几乎是不可能的，即便像著名的 MD 5, SHA 等哈希算法也无法避免这一情况，这就是散列冲突 (或者哈希冲突，哈希碰撞，**就是指多个 key 映射到同一个数组下标位置**)

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415115349515.png)


### 2.3 散列冲突-链表法（拉链）

在散列表中，数组的每个下标位置我们可以称之为桶（bucket）或者槽（slot），每个桶 (槽) 会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131410795.png)


简单就是，如果有多个 key 最终的 hash 值是一样的，就会存入数组的同一个下标中，下标中挂一个链表存入多个数据


### 2.4 时间复杂度-散列表

1. 插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O (1)

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131448070.png)

> 通过计算就可以找到元素

2. 当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除

- 平均情况下基于链表法解决冲突时查询的时间复杂度是 O (1)
    
- 散列表可能会退化为链表, 查询的时间复杂度就从 O (1) 退化为 O (n)

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131507923.png)

- 将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是 O (logn)

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131527558.png)

将链表法中的链表改造红黑树还有一个非常重要的原因，可以防止 DDos 攻击

> DDos 攻击:
> 
> 分布式拒绝服务攻击 (英文意思是 Distributed Denial of Service，简称 DDoS）
> 
> 指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个


## 3. 面试题-说一下 HashMap 的实现原理？

HashMap 的数据结构： 底层使用 hash 表数据结构，即数组和链表或红黑树

1. 当我们往 HashMap 中 put 元素时，利用 key 的 hashCode 重新 hash 计算出当前对象的元素在数组中的下标
    
2. 存储时，如果出现 hash 值相同的 key，此时有两种情况。
    

a. 如果 key 相同，则覆盖原始值；

b. 如果 key 不同（出现冲突），则将当前的 key-value 放入链表或红黑树中

3. 获取时，直接找到 hash 值对应的下标，在进一步判断 key 是否相同，从而找到对应值。

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131610294.png)

面试官追问：HashMap 的 jdk 1.7 和 jdk 1.8 有什么区别

- JDK 1.8 之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
    
- Jdk 1.8 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8） 时并且数组长度达到 64 时，将链表转化为红黑树，以减少搜索时间。扩容 resize ( ) 时，红黑树拆分成的树的结点数小于等于临界值 6 个，则退化成链表


## 4. 面试题-HashMap 的 put 方法的具体流程

### 4.1 hashMap 常见属性

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131709064.png)


### 4.2 源码分析

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131727568.png)

- HashMap 是懒惰加载，在创建对象时并没有初始化数组
    
- 在无参的构造函数中，设置了默认的加载因子是 0.75
    

添加数据流程图

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131738500.png)


具体的源码：

```Java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    //判断数组是否未初始化
    if ((tab = table) == null || (n = tab.length) == 0)
        //如果未初始化，调用resize方法 进行初始化
        n = (tab = resize()).length;
    //通过 & 运算求出该数据（key）的数组下标并判断该下标位置是否有数据
    if ((p = tab[i = (n - 1) & hash]) == null)
        //如果没有，直接将数据放在该下标位置
        tab[i] = newNode(hash, key, value, null);
    //该数组下标有数据的情况
    else {
        Node<K,V> e; K k;
        //判断该位置数据的key和新来的数据是否一样
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            //如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到
            e = p;
        //判断是不是红黑树
        else if (p instanceof TreeNode)
            //如果是红黑树的话，进行红黑树的操作
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        //新数据和当前数组既不相同，也不是红黑树节点，证明是链表
        else {
            //遍历链表
            for (int binCount = 0; ; ++binCount) {
                //判断next节点，如果为空的话，证明遍历到链表尾部了
                if ((e = p.next) == null) {
                    //把新值放入链表尾部
                    p.next = newNode(hash, key, value, null);
                    //因为新插入了一条数据，所以判断链表长度是不是大于等于8
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        //如果是，进行转换红黑树操作
                        treeifyBin(tab, hash);
                    break;
                }
                //判断链表当中有数据相同的值，如果一样，证明为修改操作
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                //把下一个节点赋值为当前节点
                p = e;
            }
        }
        //判断e是否为空（e值为修改操作存放原数据的变量）
        if (e != null) { // existing mapping for key
            //不为空的话证明是修改操作，取出老值
            V oldValue = e.value;
            //一定会执行  onlyIfAbsent传进来的是false
            if (!onlyIfAbsent || oldValue == null)
                //将新值赋值当前节点
                e.value = value;
            afterNodeAccess(e);
            //返回老值
            return oldValue;
        }
    }
    //计数器，计算当前节点的修改次数
    ++modCount;
    //当前数组中的数据数量如果大于扩容阈值
    if (++size > threshold)
        //进行扩容操作
        resize();
    //空方法
    afterNodeInsertion(evict);
    //添加操作时 返回空值
    return null;
}
```

1. 判断键值对数组 table 是否为空或为 null，否则执行 resize () 进行扩容（初始化）
    
2. 根据键值 key 计算 hash 值得到数组索引
    
3. `判断table[i]==null，条件成立，直接新建节点添加`
    
4. `如果table[i]==null ,不成立`
    
5. 4.1 判断 table[i]的首个元素是否和 key 一样，如果相同直接覆盖 value
    
6. 4.2 判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对
    
7. 4.3 遍历 table[i]，链表的尾部插入数据，然后判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现 key 已经存在直接覆盖 value
    
8. 插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold（数组长度*0.75），如果超过，进行扩容。


## 5. 面试题-讲一讲 HashMap 的扩容机制

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131831689.png)

扩容的流程：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415131841133.png)

源码：

```Java
//扩容、初始化数组
final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        //如果当前数组为null的时候，把oldCap老数组容量设置为0
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        //老的扩容阈值
        int oldThr = threshold;
        int newCap, newThr = 0;
        //判断数组容量是否大于0，大于0说明数组已经初始化
        if (oldCap > 0) {
            //判断当前数组长度是否大于最大数组长度
            if (oldCap >= MAXIMUM_CAPACITY) {
                //如果是，将扩容阈值直接设置为int类型的最大数值并直接返回
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //如果在最大长度范围内，则需要扩容  OldCap << 1等价于oldCap2
            //运算过后判断是不是最大值并且oldCap需要大于16
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
*                newThr = oldThr << 1; // double threshold  等价于oldThr*2
        }
        //如果oldCap<0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，                如果是首次初始化，它的临界值则为0
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        //数组未初始化的情况，将阈值和扩容因子都设置为默认值
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //初始化容量小于16的时候，扩容阈值是没有赋值的
        if (newThr == 0) {
            //创建阈值
            float ft = (float)newCap * loadFactor;
            //判断新容量和新阈值是否大于最大容量
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        //计算出来的阈值赋值
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        //根据上边计算得出的容量 创建新的数组        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        //赋值
        table = newTab;
        //扩容操作，判断不为空证明不是初始化数组
        if (oldTab != null) {
            //遍历数组
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                //判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作
                if ((e = oldTab[j]) != null) {
                    //将数组位置置空
                    oldTab[j] = null;
                    //判断是否有下个节点
                    if (e.next == null)
                        //如果没有，就重新计算在新数组中的下标并放进去
                        newTab[e.hash & (newCap - 1)] = e;
                    //有下个节点的情况，并且判断是否已经树化
                    else if (e instanceof TreeNode)
                        //进行红黑树的操作
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    //有下个节点的情况，并且没有树化（链表形式）
                    else {
                        //比如老数组容量是16，那下标就为0-15
                        //扩容操作*2，容量就变为32，下标为0-31
                        //低位：0-15，高位16-31
                        //定义了四个变量
                        //        低位头          低位尾
                        Node<K,V> loHead = null, loTail = null;
                        //        高位头          高位尾
                        Node<K,V> hiHead = null, hiTail = null;
                        //下个节点
                        Node<K,V> next;
                        //循环遍历
                        do {
                            //取出next节点
                            next = e.next;
                            //通过 与操作 计算得出结果为0
                            if ((e.hash & oldCap) == 0) {
                                //如果低位尾为null，证明当前数组位置为空，没有任何数据
                                if (loTail == null)
                                    //将e值放入低位头
                                    loHead = e;
                                //低位尾不为null，证明已经有数据了
                                else
                                    //将数据放入next节点
                                    loTail.next = e;
                                //记录低位尾数据
                                loTail = e;
                            }
                            //通过 与操作 计算得出结果不为0
                            else {
                                 //如果高位尾为null，证明当前数组位置为空，没有任何数据
                                if (hiTail == null)
                                    //将e值放入高位头
                                    hiHead = e;
                                //高位尾不为null，证明已经有数据了
                                else
                                    //将数据放入next节点
                                    hiTail.next = e;
                               //记录高位尾数据
                                hiTail = e;
                            }
                        }
                        //如果e不为空，证明没有到链表尾部，继续执行循环
                        while ((e = next) != null);
                        //低位尾如果记录的有数据，是链表
                        if (loTail != null) {
                            //将下一个元素置空
                            loTail.next = null;
                            //将低位头放入新数组的原下标位置
                            newTab[j] = loHead;
                        }
                        //高位尾如果记录的有数据，是链表
                        if (hiTail != null) {
                            //将下一个元素置空
                            hiTail.next = null;
                            //将高位头放入新数组的(原下标+原数组容量)位置
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        //返回新的数组对象
        return newTab;
    }
```

- 在添加元素或初始化的时候需要调用 resize 方法进行扩容，第一次添加数据初始化数组长度为 16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）
    
- 每次扩容的时候，都是扩容之前容量的 2 倍；
    
- 扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中
    
    - 没有 hash 冲突的节点，则直接使用 e.hash & (newCap - 1) 计算新数组的索引位置
        
    - 如果是红黑树，走红黑树的添加
        
    - 如果是链表，则需要遍历链表，可能需要拆分链表，判断 (e.hash & oldCap) 是否为 0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上


## 6. 面试题-hashMap 的寻址算法

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132004117.png)


在 putVal 方法中，有一个 hash (key) 方法，这个方法就是来去计算 key 的 hash 值的，看下面的代码

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132019212.png)


首先获取 key 的 hashCode 值，然后右移 16 位异或运算原来的 hashCode 值，主要作用就是使原来的 hash 值更加均匀，减少 hash 冲突

有了 hash 值之后，就很方便的去计算当前 key 的在数组中存储的下标，看下面的代码：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132034635.png)


(n-1)&hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是 2 的 n 次幂

**关于 hash 值的其他面试题：****为何 HashMap 的数组长度一定是 2 的次幂****？**

1. 计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模
    
2. 扩容时重新计算索引效率更高： hash & oldCap == 0 的元素留在原来位置，否则新位置 = 旧位置 + oldCap


## 7. 面试题-hashmap 在 1.7 情况下的多线程死循环问题

Jdk 7 的的数据结构是：数组+链表

在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132106372.png)

- 变量 e 指向的是需要迁移的对象
    
- 变量 next 指向的是下一个需要迁移的对象
    
- Jdk 1.7 中的链表采用的头插法
    
- 在数据迁移的过程中并没有新的对象产生，只是改变了对象的引用
    

  

产生死循环的过程：

线程 1 和线程 2 的变量 e 和 next 都引用了这个两个节点

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132119804.png)


线程 2 扩容后，由于头插法，链表顺序颠倒，但是线程 1 的临时变量 e 和 next 还引用了这两个节点

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132135024.png)


第一次循环

由于线程 2 迁移的时候，已经把 B 的 next 执行了 A

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132145546.png)


第二次循环

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132156142.png)


第三次循环

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132205355.png)


参考回答：

在 jdk 1.7 的 hashmap 中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环

比如说，现在有两个线程

线程一：读取到当前的 hashmap 数据，数据中一个链表，在准备扩容时，线程二介入

线程二：也读取 hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是 AB，扩容后的顺序是 BA，线程二执行结束。

线程一：继续执行的时候就会出现死循环的问题。

线程一先将 A 移入新的链表，再将 B 插入到链头，由于另外一个线程的原因，B 的 next 指向了 A，

所以 B->A->B, 形成循环。

当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），**尾插法**，就避免了 jdk 7 中死循环的问题。


## 8. 面试题-HashSet 与 HashMap 的区别

(1) HashSet 实现了 Set 接口, 仅存储对象; HashMap 实现了 Map 接口, 存储的是键值对.

(2) HashSet 底层其实是用 HashMap 实现存储的, HashSet 封装了一系列 HashMap 的方法. 依靠 HashMap 来存储元素值, (利用 hashMap 的 key 键进行存储), 而 value 值默认为 Object 对象. 所以 HashSet 也不允许出现重复值, 判断标准和 HashMap 判断标准相同, 两个元素的 hashCode 相等并且通过 equals () 方法返回 true.

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250415132230108.png)


## 9. 面试题-HashTable 与 HashMap 的区别

> 难易程度：☆☆
> 
> 出现频率：☆☆

主要区别：

|   |   |   |
|---|---|---|
|区别|HashTable|HashMap|
|数据结构|数组+链表|数组+链表+红黑树|
|是否可以为 null|Key 和 value 都不能为 null|可以为 null|
|hash 算法|key 的 hashCode ()|二次 hash|
|扩容方式|当前容量翻倍 +1|当前容量翻倍|
|线程安全|同步 (synchronized) 的，线程安全|非线程安全|

在实际开中不建议使用 HashTable，在多线程环境下可以使用 ConcurrentHashMap 类


# 二. 真实面试还原

## 1. HashMap

```java
面试官：说一下HashMap的实现原理？

候选人：

嗯。它主要分为了以下几个部分：

1，底层使用hash表数据结构，即数组+（链表 | 红黑树）

2，添加数据时，计算key的值确定元素在数组中的下标

key相同则替换

不同则存入链表或红黑树中

3，获取数据通过key的hash计算数组下标获取元素

面试官：HashMap的jdk1.7和jdk1.8有什么区别

候选人：

- JDK1.8之前采用的拉链法，数组+链表
    
- JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树
    

面试官：好的，你能说下HashMap的put方法的具体流程吗？

候选人：

嗯好的。

1. 判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）
    
2. 根据键值key计算hash值得到数组索引
    
3. 判断table[i]==null，条件成立，直接新建节点添加
    
4. 如果table[i]==null ,不成立
    

4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value

4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对

4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value

5. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。
    

面试官：好的，刚才你多次介绍了hsahmap的扩容，能讲一讲HashMap的扩容机制吗？

候选人：

好的

- 在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）
    
- 每次扩容的时候，都是扩容之前容量的2倍；
    
- 扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中
    
- 没有hash冲突的节点，则直接使用 e.hash & (newCap - 1) 计算新数组的索引位置
    
- 如果是红黑树，走红黑树的添加
    
- 如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash & oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上
    

面试官：好的，刚才你说的通过hash计算后找到数组的下标，是如何找到的呢，你了解hashMap的寻址算法吗？

候选人：

这个哈希方法首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位异或运算得到最后的hash值。

在putValue的方法中，计算数组下标的时候使用hash值与数组长度取模得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了数组长度-1 得到一个值，用这个值按位与运算hash值，最终得到数组的位置。

面试官：为何HashMap的数组长度一定是2的次幂？

候选人：

嗯，好的。hashmap这么设计主要有两个原因：

第一：

计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模

第二：

扩容时重新计算索引效率更高：在进行扩容时会进行判断 hash值按位与运算旧数组长租是否 == 0

如果等于0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标+旧数组长度

  

面试官：好的，我看你对hashmap了解的挺深入的，你知道hashmap在1.7情况下的多线程死循环问题吗？

候选人：

嗯，知道的。是这样

jdk7的的数据结构是：数组+链表

在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环

比如说，现在有两个线程

线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入

线程二也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。

当线程一再继续执行的时候就会出现死循环的问题。

线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B->A->B,形成循环。

当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），**尾插法**，就避免了jdk7中死循环的问题。

面试官：好的，hashmap是线程安全的吗？

候选人：不是线程安全的

面试官：那我们想要使用线程安全的map该怎么做呢？

候选人：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap

面试官：那你能聊一下ConcurrentHashMap的原理吗？

候选人：好的，请参考《多线程相关面试题》中的ConcurrentHashMap部分的讲解
```

```java
面试官：HashSet与HashMap的区别？

候选人：嗯，是这样。

HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.

面试官：HashTable与HashMap的区别

候选人：

嗯，他们的主要区别是有几个吧

第一，数据结构不一样，hashtable是数组+链表，hashmap在1.8之后改为了数组+链表+红黑树

第二，hashtable存储数据的时候都不能为null，而hashmap是可以的

第三，hash算法不同，hashtable是用本地修饰的hashcode值，而hashmap经常了二次hash

第四，扩容方式不同，hashtable是当前容量翻倍+1，hashmap是当前容量翻倍

第五，hashtable是线程安全的，操作数据的时候加了锁synchronized，hashmap不是线程安全的，效率更高一些

在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类
```