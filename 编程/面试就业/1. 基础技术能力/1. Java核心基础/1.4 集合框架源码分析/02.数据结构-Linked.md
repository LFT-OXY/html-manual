# 数据结构-Linked

## 一、数据结构链表

前置知识，内存碎片。才能知道链表厉害的地方在哪里？

![image-20250416105845826](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161058913.png)

LinkedList的简略内部布局草图如下：

![image-20250416110322663](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161103734.png)

## 二、集合框架源码解读 LinkedHashMap

LinkedList、LinkedHashMap 二选一。



LinkedHashMap ： 让无序的HashMap，变成有序的。

### 1. 先看类继承关系

```JAVA
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>
```

> 能看出，继承HashMap，有HashMap的结构！ 数组+链表+红黑树。

### 2. 看构造方法

```java
public LinkedHashMap() {
    super(); //实例化了一个HashMap
    accessOrder = false; //排序的
}
```

> 跳过其他构造方法，因为我猜，其他构造方法，都有用到super(); 
>
> 扩展知识，super和this是什么？在哪里？是变量么？JVM环节讲。super很难。

### 3. 看属性+内部类

```java
//head头部指针
transient LinkedHashMap.Entry<K,V> head;


//tail尾部指针
transient LinkedHashMap.Entry<K,V> tail;

//是否排序 
final boolean accessOrder;

//-----------------上面是LinkedHashMap的属性------
//-----------------下面是HashMap的属性------
	//存放内部数据的 数组实现
    transient Node<K,V>[] table;
	//所有元素，可以拆开变成 keySet和values
    transient Set<Map.Entry<K,V>> entrySet;
	//你猜 元素个数
    transient int size;
	//操作数
    transient int modCount;
	//阈值，扩容阈值： 数组长度* 负载因子0.75 = 阈值  16*0.75 = 12 阈值就是12
    int threshold;
	//负载因子 0.75
    final float loadFactor;
```

因为我们要研究一下LinkedHashMap.Entry<K,V> 内部类！它就是HashMap.Node<K,V>

```java
static class Entry<K,V> extends HashMap.Node<K,V> {
    //before和after是什么？ 有先后顺序了！
    Entry<K,V> before, after;
    /*
    HashMap.Node内部类的一些属性：
        final int hash; //hash值
        final K key; //key
        V value;
        Node<K,V> next; //下一个节点
    */
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
```

![image-20250416112625735](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161126802.png)

### 4. CRUD

#### 4.1 新增

发现LinkedHashMap没有put方法！用的是HashMap的put！！！

那什么时候是最合适用来排序的时间？



HashMap的put方法的一部分：

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            //newNode节点，然后，放入数组中。
            tab[i] = newNode(hash, key, value, null);
       
        …… 后面点先不看，等讲HashMap底层再研究
    }
```

核心是newNode的方法，有LinkedHashMap重写 了下面这个方法

```java
/*
以下受包保护的方法被设计为被 LinkedHashMap 覆盖，但不能被任何其他子类覆盖。几乎所有其他内部方法也都受包保护，但被声明为 final，因此可以由 LinkedHashMap、视图类和 HashSet 使用。
 */

// Create a regular (non-tree) node
Node<K,V> newNode(int hash, K key, V value, Node<K,V> next) {
    return new Node<>(hash, key, value, next);
}
```

重写后：

```java
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    //实例化Entry<K,V> 实体类， 和HashMap一样
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<>(hash, key, value, e);
    //这一行才是排序的那一行
    linkNodeLast(p);
    return p;
}
```

具体的排序方法:

```java
private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
    //把链表最后一个尾节点赋值给变量 last
    LinkedHashMap.Entry<K,V> last = tail;
    // 把尾节点 赋值我们新插入的数据
    tail = p;
    //如果last是空，则尾节点又是头节点
    if (last == null)
        head = p;
    else {
        //新数据的 上一个节点，绑定之前的尾节点
        p.before = last;
        //之前的尾节点的下一个节点，绑定新插入的节点。
        last.after = p;
    }
}
```

逻辑图如下：

![image-20250416115258450](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161152564.png)

再画一个双向链表的逻辑图：

![image-20250416115620931](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161156033.png)

#### 4.2 删除

发现LinkedHashMap是没有remove方法的。所以，还是要看HashMap的删除方法

```java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
  ……前面设置伪代码
    //遍历整个元素，找到目标值。
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
    
   ……伪代码 mode就是要被删掉的元素
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
           //p是arr[index] 某个下标实际值
           if (node == p)
               //0123，我要删掉2, 下标2的值换成3  013
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            //关键代码来了 ，会发现，HashMap没有实现这个方法逻辑的
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
```



最后发现是LinkedHashMap实现这个方法 afterNodeRemoval， 下面这个具体实现代码是LinkedHashMap

```java
void afterNodeRemoval(Node<K,V> e) { // unlink
    LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e;
    LinkedHashMap.Entry<K,V> b = p.before,
    LinkedHashMap.Entry<K,V> a = p.after;
    p.before = p.after = null;
    //下面的所有操作，就是 断开链条，越过删除的节点，前后绑定
    if (b == null)
        head = a;
    else
        //把删的上一个节点的after连上被删的节点的下一个节点
        b.after = a;
    //反过来
    if (a == null)
        tail = b;
    else
        a.before = b;
}
```

删除逻辑图如下：

![image-20250416120922204](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161209323.png)



## 三、链表数据结构与算法

### 1. 单向链表

![image-20250416140713240](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161407380.png)



```java
package com.woniuxy.linked;

import java.util.NoSuchElementException;

/**
 * @Author: 马宇航
 * @Todo: 自定义单向链表
 * @DateTime: 25/04/16/星期三 14:08
 * @Component: 成都蜗牛学苑
 **/
public class MySingleLinked {
    //定义一个头节点： 单项链表的头。
    private Node head;
    int size;
    //内部类，来定义我们的存放的元素数据吧
    private class Node {
        Object data;
        Node next;
        public Node(Object data, Node next) {
            this.data = data;
            this.next = next;
        }
    }
    //添加元素
    public void add(Object data) {
        //判断头节点是否为空
        if (head == null) {
            head = new Node(data, null);
        }else{
            //非空怎么办？ 什么时候用while 什么时候用for
            Node now = head;
            while (now.next != null) {
                //指针往后移动 一步!!!
                now = now.next;
            }
            //当next是null的时候，新增尾节点在最后一个节点上
            now.next = new Node(data, null);
        }
        size++;
    }
    //删除元素
    public void remove(Object data) {
        //判断头节点是否为空
        if (head == null) {
            throw new NoSuchElementException();
        }
        //遍历,一个一个判断
        Node now = head;
        Node prev = now; //记住上一个节点
        do{
            //指针往后移动 一步!!!
            if (now.data.equals(data)) {
                //相同就删除
                //删除的逻辑,需要一个变量 记住上一个节点.
                prev.next = now.next;
                break;
            }
        }while ((now =(prev = now).next) != null);
        //如果没匹配成功,都循环完了,我怎么知道 没匹配成功呢? now都指向了null,说明没找到数据.
        if (now != null) {
            size--;
        }else{
            throw new NoSuchElementException();
        }
    }
    //获取元素 通过索引获取,还是通过元素或者

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("[");
        Node now = head;
        while (now!= null) {
            stringBuilder.append(now.data).append(",");
            now = now.next;
        }
        stringBuilder.append("]");
        return stringBuilder.toString();
    }

    public static void main(String[] args) {
        MySingleLinked mySingleLinked = new MySingleLinked();
        for (int i = 0; i < 10; i++) {
            mySingleLinked.add(i+"");
        }
        mySingleLinked.remove("1");
        System.out.println(mySingleLinked.toString());
    }
}
```

### 2. 双向链表

![image-20250416150836770](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161508930.png)

```java
package com.woniuxy.linked;

import java.util.List;

/**
 * @Author: 马宇航
 * @Todo: 双向链表:
 * @DateTime: 25/04/16/星期三 15:09
 * @Component: 成都蜗牛学苑
 **/
public class MyLinkedList {
    //定义一个头节点： 单项链表的头。
    Node head;
    Node tail;
    int size;
    //内部类，来定义我们的存放的元素数据吧
    private static class Node{
        Node next,prev;
        Object data;

        public Node(Node next, Node prev, Object data) {
            this.next = next;
            this.prev = prev;
            this.data = data;
        }
    }
    //添加元素 默认尾插
    public void add(Object data) {
        //判断头节点是否为空
        if (head == null) {
            head = new Node(null,null,data);
            tail = head;
        }else{
            //非空怎么办？ 什么时候用while 什么时候用for
            Node now = tail;
            //新增尾节点在最后一个节点上
            now.next = new Node(null,now,data);
            tail = now.next;
        }
        size++;
    }
    //头插
    public void addFirst(Object data) {
        if (head == null) {
            head = new Node(null,null,data);
            tail = head;
        }else{
            //头部有数据
            Node now = head;
            now.prev = new Node(now,null,data);
            head = now.prev;
        }
        size++;
    }
    //定义中间节点的指针数据 findMiddle
    public void findMiddle() {
        //快慢指针
        Node slow = head,fast = head;
        while(fast.next!=null){
            try {
                fast = fast.next.next;
                slow = slow.next;
                if (fast.next == null) {
                    System.out.println("中间节点是:" + slow.data);
                    break;
                }
            }catch (Exception e){
                System.out.println("中间节点是:" + slow.data);
                e.printStackTrace();
                break;
            }
        }
    }

    public static void main(String[] args) {
        MyLinkedList myLinkedList = new MyLinkedList();
        for (int i = 0; i < 100; i++) {
            myLinkedList.add(i+"");
        }
        myLinkedList.findMiddle();
    }
}
```

> 额外注意的是，快慢指针，找中间节点的功能。
>
> 理解这个快慢指针。

### 3. 循环链表



![image-20250416153518062](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504161535211.png)

> 新增和遍历。



### 4. 链表找环

```java
package com.woniuxy.linklist.singly;

/**
 * @Author: 马宇航
 * @Todo: 开发一个单向链表
 * @DateTime: 25/02/12/0012 10:34
 * @Component: 成都蜗牛学苑
 **/
public class CircleLinkedFindPoint {
    @Override
    public String toString() {
        String result = "linked:[";
        Node node = head;
        while (true){
            if (node.next==null){
                result += node.data;
                break;
            }
            //这里就能看见输出的环的结果：K J I H G F E D C B A F E D C B A F E D C B A F E…… 
            System.out.print(node.data +" ");
            result += node.data+",";
            node=node.next;
        }
        result+="]";
        return result;
    }

    //指向第一个链表Node节点
    Node head = null;
    //统计链表长度的变量
    int size;

    public void addNode(Node data){
        //判断链表有没有数据
        if(isEmpty()){//true就表示空的链表
            head = data;
            size++;
        }else{
            //head有值么？有
            Node temp = head;//临时存储头节点原本的链表数据
            //下面是新插入的数据，next指向之前的 head头数据
            head = data;
            size++;
        }
    }
   
    //修改通过下标修改, 这个可以手动修改，我某个节点的元素，让它手动变成环
    public void set(int index,Node data){
        Node now = head;
        //下标有没有越界
        if (index >= size){
            throw  new IndexOutOfBoundsException();
        }else {
            for (int i = 0; i < index; i++) {
                    now=now.next;
                }
            now.next=data;
        }
    }
    
    private boolean isEmpty() {
        if (size==0){
            return true;
        }else {
            return false;
        }
    }

    /**
    * @Author: 马宇航
    * @Todo: 以后如果要设计自己的数据结构，那么就需要自定义内部类，用来配置我们的内部节点
    * @DateTime:  25/02/12/0012 10:35
    * @Component: 成都蜗牛学苑
    **/
    public static class Node{
        Object data;
        Node next;

        public Node() {
        }

        public Node(Object data, Node next) {
            this.data = data;
            this.next = next;
        }
    }
}
```

测试类：

```JAVA
package com.woniuxy.linklist.singly;

/**
 * @Author: 马宇航
 * @Todo: TODO
 * @DateTime: 25/02/12/0012 14:46
 * @Component: 成都蜗牛学苑
 **/
public class TestCircleDemo {
    public static void main(String[] args) {
        CircleLinkedFindPoint circleLinkedFindPoint = new CircleLinkedFindPoint();
        CircleLinkedFindPoint.Node first = new CircleLinkedFindPoint.Node("A",null);
        circleLinkedFindPoint.addNode(first);
        CircleLinkedFindPoint.Node first1 = new CircleLinkedFindPoint.Node("B",first);
        circleLinkedFindPoint.addNode(first1);
        CircleLinkedFindPoint.Node first2 = new CircleLinkedFindPoint.Node("C",first1);
        circleLinkedFindPoint.addNode(first2);
        CircleLinkedFindPoint.Node first3 = new CircleLinkedFindPoint.Node("D",first2);
        circleLinkedFindPoint.addNode(first3);
        CircleLinkedFindPoint.Node first4 = new CircleLinkedFindPoint.Node("E",first3);
        circleLinkedFindPoint.addNode(first4);
        CircleLinkedFindPoint.Node first5 = new CircleLinkedFindPoint.Node("F",first4);
        circleLinkedFindPoint.addNode(first5);
        CircleLinkedFindPoint.Node first6 = new CircleLinkedFindPoint.Node("G",first5);
        circleLinkedFindPoint.addNode(first6);
        CircleLinkedFindPoint.Node first7 = new CircleLinkedFindPoint.Node("H",first6);
        circleLinkedFindPoint.addNode(first7);
        CircleLinkedFindPoint.Node first8 = new CircleLinkedFindPoint.Node("I",first7);
        circleLinkedFindPoint.addNode(first8);
        CircleLinkedFindPoint.Node first9 = new CircleLinkedFindPoint.Node("J",first8);
        circleLinkedFindPoint.addNode(first9);
        CircleLinkedFindPoint.Node first10 = new CircleLinkedFindPoint.Node("K",first9);
        circleLinkedFindPoint.addNode(first10);
        circleLinkedFindPoint.set(9,new CircleLinkedFindPoint.Node("A",first5));
        System.out.println(circleLinkedFindPoint);
        //开发代码 验证circleLinkedFindPoint链表 有环！
        //寻找环起点，判断是不是F，再找相遇点。
    }
}
```

上诉代码,生成的逻辑图:

![image-20250417101443527](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504171014756.png)

链表找环的 网上的图: 下图的k是 环的周长 , A 是起点到环起点的距离。m是环起点到相遇点的距离。

![双指针技巧的小结](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202302061416997.png)

> 思路，先判断有没有环。
>
> 接着判断相遇点。
>
> 最后才能找到环起点。
>
> 纯粹物理 追逃 问题。
>
> 
>
> 解决思路，快慢指针。
>
> 
>
> ```cmd
> slot速度 v
> fast速度 2v
> 都从起点往外走，(fast)Sf路程 = 2(slot)Ss路程
> 设：头节点到环起点距离 = x  ， k是周长, m是环起点到相遇点的距离
> （慢指针的路程Ss）相遇点 = x + m
> (快指针的路程Sf) 相遇点 = Ss + k
> 得：根据路程关系
> (fast)Sf路程 = (x+m) + k
> (slot)Ss路程 = x + m
> 根据 Sf = 2Ss
> 推出： (x+m) + k = 2（x + m）
> 最终得到：k = x + m  ---> x = k - m
> 
> 也就是说，怎么找环起点？
> 快指针从相遇点开始，和慢指针利用同样的速度，开始运行：
> slot 速度v
> fast 速度v
> 快指针走的路程 ：k-m
> 慢指针走的路程 ：x 有因为x = k-m
> 所以，他们的路程就是一样的. 
> 最终的相遇点必然是 环起点。
> 
> 回答，万一，k可能是n圈，把k变成  nk，n是循环的圈速。不影响结果。
> 慢指针走的路程 ：x = nk-m
> 快指针走的路程 ：nk-m 
> ```
>
> 

```java
main{
//找到相遇点
    Node meetingPoint = findMeetingPoint(circleLinkedFindPoint);
    System.out.println("相遇点:"+meetingPoint.data);
    //找到环起点
    Node startCirclePoint = findStartCirclePoint(circleLinkedFindPoint,meetingPoint);
    System.out.println("环的起点:"+startCirclePoint.data);
}
private static Node findMeetingPoint(CircleLinkedFindPoint circleLinkedFindPoint) {
    Node fast = circleLinkedFindPoint.head;
    Node slow = circleLinkedFindPoint.head;
    try {
        //当他们相遇的时候就结束循环
        while (true) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                break;
            }
        }
    }catch (Exception e){
        System.out.println("没有相遇点");
        e.printStackTrace();
    }
    //结束循环就是相遇点
    return fast;
}
private static Node findStartCirclePoint(CircleLinkedFindPoint circleLinkedFindPoint,
                                         Node meetingPoint) {
    //慢指针从头往后走
    Node slow = circleLinkedFindPoint.head;
    //快指针 从相遇点往后走
    Node fast = meetingPoint;
    while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
    }
    return fast;
}
```