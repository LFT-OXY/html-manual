

# 数据结构-Hash

## 一、定义

Hash音译过来叫哈希，翻译过来叫做散列。



什么是散列？

在百度百科中，散列（Hash）通常被定义为一种将数据（如字符串、数字等）通过特定的**散列函数**转换为**固定长度**的散列值的计算过程。这个过程具有以下特点：

1. **唯一性**：理想情况下，**不同的输入数据**应产生不同的散列值（但是不一定，为什么？）。
2. **不可逆性**：从散列值难以逆向推导出原始数据（就像一个人，把它变成2半，还能推出原本长什么样子么？）。
3. **高效性**：散列函数的计算速度通常很快（O(1)）。

散列在计算机科学中有广泛的应用，如**数据存储、加密、数据完整性校验**等。常见的散列函数包括**MD5、SHA-1、SHA-256**等。

![image-20210713093250598](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210713093250.png)



散列算法追求的是什么？

> 追求，尽可能不重复，均匀分布。

### 1. Hash算法

>Hash算法也叫做散列算法，不可逆加密体系。（额外补充，Bash64加密就是一种可逆加密，异或加密。）

### 2. 特点

1. `确定性`，散列后的值不相同，那么原始值一定不同。MD5密码加密。（MD5，压缩包下载是否完整）
2. `散列冲突`: 输入值不同，散列的值经过压缩后相同，比如HashMap，hash(key) -->计算下标，就会出现冲突。
3. `不可逆性`：散列后的值，无法推出原始值。
4. `混淆特性`:  加盐加密（MD5+盐），散列的基础上做一个额外的散列。改变部分内容，得到不同散列值。



> 散列函数：最简单函数，取模。

## 二、散列表

> 数据结构（通常都是Array） + 散列算法（散列值 某些计算 =下标） = 散列表（通过下标存储数据）
>
> 就会出现碰撞概率，肯定会碰撞的。

### 1. 负载因子

> 引入负载因子，用来，**降低碰撞的概率的**。
>
> 如果负载因子是1%, 100个格子里面,放入1个元素,就达到 负载因子的要求, 就会触发数组扩容.  
>
> 就会极度降低出现碰撞的概率. 
>
> 大佬经过计算: 16个数组长度, 0.75的负载因子, 出现冲突的概率,就只有 0.6 . 如果冲突了8次,  概率是千万分之6. 

```cmd
HashMap底层注释 写的 负载因子
对于默认大小调整阈值 0.75，参数平均约为 0.5，尽管由于调整大小粒度的原因，差异很大。忽略方差，列表大小 k 的预期出现次数为 （exp（-0.5） pow（0.5， k） factorial（k））。
第一个值是： 
0： 0.60653066 
1： 0.30326533 
2： 0.07581633 
3： 0.01263606 
4： 0.00157952 
5： 0.00015795 
6： 0.00001316 
7： 0.00000094 
8： 0.00000006 
更多： 小于 10000 万分之一
```

![image-20250417121809252](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504171218402.png)

### 2. 桶 buckets

JDK的官方文档里面写的, 桶就是值 数组上的一个格子，散列表的一个下标对应的元素。

一个桶可以放入很多数据，表明，Hash表的冲突解决方案，就是在一个桶里面，垒起来。

1. 链表法（拉链法）
2. 红黑树

### 3. 散列冲突解决方案（并非仅仅是HashMap）

1. 开放寻址法：（m为表长度，di为增量<除了下面所说的增量方式,还有一个随机增量>）

   1.1. 常用之一：线性探测法（di是等差1,2,3,4,5，.....） ± di 方案

   1.2. 常用之二: 二次探测法（平方再探测di=±(1^2^), ±(2^2^.)....）index ± di

   1.3. 常用之三(最好的一种方法): 双重散列，公式如下：

   ```
   hi=(hash(key)+ i*hash1(key))%m(0≤i≤m-1) //即di=i*h1(key)  i = ±1，±2
   ```

2. 拉链法：HashMap的解决方案，如果下表就算冲突，则使用链表，尾插法来实现我们的hash冲突的解决。

## 三、HashMap底层源码

> 先不考虑JDK1.7的方案，数组+链表，使用头插法来实现的 冲突解决方案。然后高并发下会造成，链表形成环。

常见面试题：

> 八股文不要嫌弃，但是它是最容易判断，你的基本功，同时有没有为了面试做好准备，态度问题，看你面试是否重视。

2k~4k面试题：

1. HashMap默认初始容量是多少？扩容2次分别容量是多少？
2. HashMap默认负载因子多少？为什么是这么多？
3. HashMap的数据结构是什么？为什么要有红黑树？

4k~8k:

1. 扩容的时候会发生什么？
2. 下标怎么计算的？
3. 什么时候链表转红黑树？为什么？什么时候转回链表？为什么中间要隔一个数字？时间复杂度。

8k~12k:

1. 并发开发的时候，为什么不能选择HashMap？那应该怎么选择？
2. HashMap的Hash表长度，为什么一定要是2的幂次方倍？初始化的时候，指定37容量的时候，会变成多少？
3. 红黑树中的左右旋怎么旋的？

20k: 一般高级和架构师不得问具体的集合底层实现api源码。问框架底层和解决方案为主。

1. ConcurrentHashMap底层具体逻辑实现；
2. 并发的时候，加锁为什么性能不好？为什么不适用Synchronized？
3. 遇到高并发情况，你如何选择加锁还是用MQ，还是用redis!
4. 解决具体场景下，MQ的方案和Redis的方案！

> 面试问这些的目的：只是为了判断你有没有阅读研究源码的习惯，礼貌的开场，来点耳熟能详的八股文，大致看你能给到什么等级的答案。

### 1. 先看继承关系

> Key-value双列结构。支持克隆。支持序列化。
>
> 类名中 Hash很关键，一定有Hash表的特点。

```JAVA
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
}
```

### 2. 构造方法

```java
public HashMap() {
    //赋予初始负载因子 0.75f
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
//执行容量和自定义的负载因子
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity > MAXIMUM_CAPACITY ) //MAXIMUM_CAPACITY 1<<30
        initialCapacity = MAXIMUM_CAPACITY;
    this.loadFactor = loadFactor;
    //确定Hash表长度一定是2的指数倍
    this.threshold = tableSizeFor(initialCapacity);
}
//cap = 12
ｒｅｔｕｒｎ　ｎ＋１　＝　１６　正好是２的指数倍
static final int tableSizeFor(int cap) {
    /*
    -1 >>>　２８
    -１补码：1111 1111 1111 1111 1111 1111 1111 1111 
    0000 0000 0000 0000 0000 0000 0000 1111 　１５
    ｎ＝　１５
    */
    int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
//接下来，这个怎么能确保必须是2的指数倍呢？
public static int numberOfLeadingZeros(int i) {
    // HD, Count leading 0's
    if (i <= 0)
        return i == 0 ? 32 : 0;
    //n= 0000 0000 0000 0000 0000 0000 0001 1111 
    int n = 31;
    // i = 12 - 1 = 0000 0000 0000 0000 0000 0000 0000 1011 
    //  i>= 65536 
    if (i >= 1 << 16) { n -= 16; i >>>= 16; }
    //  i >= 256
    if (i >= 1 <<  8) { n -=  8; i >>>=  8; }
    // i >= 16
    if (i >= 1 <<  4) { n -=  4; i >>>=  4; }
    // i >= 4
    if (i >= 1 <<  2) {
        // n = n - 2 = 29
        n -=  2; 
        /*
        i = i >>> 2;
		i = 0000 0000 0000 0000 0000 0000 0000 1011 
		>>> 2  无符号右移
		————————————————————————————————————————————
		0000 0000 0000 0000 0000 0000 0000 0010  = 2
        */
        i >>>=  2; 
    }
    //i>>>1 = 1
    // n = 29- 1 = 28
    return n - (i >>> 1);
}
```

> 补充原反补的二进制计算知识：
>
> ```java
> int i = -4;
> System.out.println(i << 1);//左移一位 -8
> /*
> 原码: 0000 0000 0000 0000 0000 0000 0000 0100
> 反码: 1111 1111 1111 1111 1111 1111 1111 1011
> 补码: 1111 1111 1111 1111 1111 1111 1111 1100  反码 + 1
>  >> 1 (带符号右移)
> 补码 1111 1111 1111 1111 1111 1111 1111 1110  补码 --取反+1-> 原码
> 反码 0000 0000 0000 0000 0000 0000 0000 0001
> 原码 0000 0000 0000 0000 0000 0000 0000 0010 反码 + 1
> 数值是 2, 但是补码是负数,所以要加个 负号
> */
> System.out.println(i >> 1);//右移一位 -2
> /*
> 正数原反补都一样.
> 负数的二进制怎么计算: 原,反,补  -4的原码不考虑符号
> 原码: 0000 0000 0000 0000 0000 0000 0000 0100
> 反码: 1111 1111 1111 1111 1111 1111 1111 1011
> 补码: 1111 1111 1111 1111 1111 1111 1111 1100  反码 + 1
> -4在计算机中拿来计算的 二进制是上面的补码
> -4 >>> 1 无符号右移(补码不考虑符号位,都当做数据来移动) 高位补0
> 0111 1111 1111 1111 1111 1111 1111 1110  补码 是正数了, 原码也是这个
> */
> System.out.println(i >>> 1);//无符号右移 2147483646
> 
> 
> /*
>         1 - 1  为什么等于0?
>         1当做16位二进制
>         正数1的二进制: 0000 0001
>         负数1的
>         原码: 0000 0001 
>         反码: 1111 1110
>         补码: 1111 1111
>         ---------------
>         计算机是补码计算:
>         0000 0001
>         1111 1111 +
>         ----------
>       1 0000 0000
>         但是我不想画32位,用的8位来计算, 溢出了8位,则舍弃最终就是 
>         0000 0000
>       */
> ```

### 3. 内部属性和内部类

```java
默认数组长度
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
默认最大长度
static final int MAXIMUM_CAPACITY = 1 << 30;
默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
默认链表转红黑树的阈值
static final int TREEIFY_THRESHOLD = 8;
默认红黑树转回链表的阈值
static final int UNTREEIFY_THRESHOLD = 6;
最小转红黑树的数组长度
static final int MIN_TREEIFY_CAPACITY = 64;
不参与序列化的ｈａｓｈ表数据
transient Node<K,V>[] table;
所有元素的集合
transient Set<Map.Entry<K,V>> entrySet;
元素数据的数量
transient int size;
修改次数
transient int modCount;
扩容阈值
int threshold;
负载因子
final float loadFactor;
```

内部类：

```java
单向链表，数组上存放的就是这个Ｎｏｄｅ节点。
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;　

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
}
红黑树的内部节点元素内容
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // red-black tree links
        TreeNode<K,V> left;
        TreeNode<K,V> right;
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;　//ｒｅｄ属性 红黑树　ｂｏｏｌｅａｎ　
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
}
```

### 4. 新增(HashMap最重要的代码)

新增方法第一步:

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

第二步:hash(key)

```java
static final int hash(Object key) {
    int h;
    //key.hashCode() -->底层实现,对象是C写的,但是如果是字符串 Stirng.hashCode()
    // ^ (h >>> 16) 为什么要做这个事情?
    /*
    h: 0010 0110 0010 0101 0100 1000 0100 0111
h>>>16 0000 0000 0000 0000 0010 0110 0010 0101
----------------------------------------------- ^ 异或  做了高位和低位的混淆, 增加了低位的复杂度, 可能有很多值 进行hashCode计算后,低位一样, 所以和高位混淆,可以降低冲突的概率
	   0010 0110 0010 0101 0110 1110 0110 0010  
    */
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```





第三步:

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    //用来存放 旧数组
    Node<K,V>[] tab;
    //hash冲突的节点
    Node<K,V> p; 
    //n是数组长度, i存放冲突的index
    int n, i;
    //刚new出来,就put第一个元素
    //如果是刚实例化, table HashMap中存放的数据,里面是空.
    if ((tab = table) == null || (n = tab.length) == 0)
        //一来就要扩容: 0 -->16结束
        n = (tab = resize()).length;
    
    //后续put方法第二个元素
    /*
   		 第一步:(n - 1) & hash, 这句话就决定了为什么数组长度必须是2的幂次方倍
   		 	为什么?
   		 	n-1 二进制  0000 1111
   		 	hash二进制  xxxx xxxx   x是未知数
   		 	---------------------- & 有0则0
   		 			   0000 xxxx ---> 数值范围(0-15) 任何都有可能
   		 	为什么一定要2的指数倍?反证法!		   
   		 	假设n=9, n-1=8
   		 	8二进制     0000 1000
   		 	hash二进制  xxxx xxxx   x是未知数
   		 	---------------------- & 有0则0
    		 		   0000 x000 ---> 数值范围(0和8)
   		 第二步:i = 第一步结果
   		 第三步:tab[index]
   		 第四步:p = 头节点
    */
    //判断,新插入的节点,有没有冲突, 如果没冲突 就是该下标没数据为null
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    //下面就是拉链法解决Hash冲突
    else {
        Node<K,V> e; K k;
        //插入的节点,是否和头节点一样。 p是头节点
        if (p.hash == hash && //hash值的判断，如果hash相同，很有可能就是同一个元素
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p; //如果相同，则变量e赋值位头节点
        //判断头节点是否为树节点 
        else if (p instanceof TreeNode)
            //红黑树的插入算法 不考虑先
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            //链表，遍历 尾插
            for (int binCount = 0; ; ++binCount) {
                //e指针后移 ==null 后面就没有数据来
                if ((e = p.next) == null) {
                    //直接尾插
                    p.next = newNode(hash, key, value, null);
                    //判断 循环次数是否大于等于 8-1，循环几次8次 第9个元素插入后会变红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        //转红黑树代码，数组长度必须大于等于64的限制 才会变红黑树，否则是扩容
                        treeifyBin(tab, hash);
                    break;
                }
                //如果和中间某个值是一样的。
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k)))){
                    break;
                }
                //两个先后指针 p在后,e在前
                p = e;
            }
        }
        //e不等于空,说明有匹配上的相同节点
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                //这里在赋值，put了两个 相同的key，只是把value重新覆盖了
                e.value = value;
            //LinkedHashMap底层执行
            afterNodeAccess(e);
            return oldValue;
        }
    }
    //当插入的是新节点的时候.尾插成功
    ++modCount;
    if (++size > threshold) //size是当前元素个数 >12 表示插入的是第13的一个元素
        resize();//扩容
    //LinkedHashmap
    afterNodeInsertion(evict);
    return null;
}
```

### 5. resize()扩容方法(接上一个4)

> 新增引出的第二个重点扩容!

```java
final Node<K,V>[] resize() {
    //第一次扩容 oltTab = null
    Node<K,V>[] oldTab = table;
    //旧表的容量 0
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    //旧表的扩容阈值 12 = 容量*负载因子
    int oldThr = threshold; //
    int newCap, newThr = 0;
    //第一次put进不去
    if (oldCap > 0) {
        //几乎进不去
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;//Integer.MAX_VALUE =(1<<31) -1
            return oldTab;
        }
        //newCap=旧表容量*2   旧表容量(有可能是8 4 2)大于等于16
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            //把扩容阈值*2 , 比如之前是12 << 1 = 24  == newThr
            newThr = oldThr << 1; // double threshold
    }
    //第一次扩容 0-->16 这里进不去 oldThr =0
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    //这里就是第一次扩容
    else {               // zero initial threshold signifies using defaults
        //新容量 = 16
        newCap = DEFAULT_INITIAL_CAPACITY;
        //newThr = 12 = 0.75f * 16
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    //第一次扩容进去的
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    
    //全局属性赋值 新的阈值 12
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    //实例化一个16长度的数组
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    //全局属性 table就有一个具体的数组地址
    table = newTab;
    //说明是16-->32(也可能是2-->4-->8) newCap = 32 oldCap=16 newThr = 24 oldThr = 12
    if (oldTab != null) {
        // 记住这四个字: 扩容拆链.   不想变红黑树,需要把链表拆开2份 存放, 否则扩容就没意义.
        for (int j = 0; j < oldCap; ++j) {//遍历旧的数组的所有下标
            //设置变量e 指针
            Node<K,V> e;
            //拿到头节点 赋值给e  假设下标都是5
            if ((e = oldTab[j]) != null) {
                //头节点断链
                oldTab[j] = null;
                //如果头节点下一个节点是空,说明链表只有1个元素
                if (e.next == null)
                    //重新计算 存入新数组中 但是不确定是高位还是低位
                    /*
                    现在的链表本身下标是 5 -> 0000 0101
                    0000 1111 oldCap -1 = 15
                    0001 1111 newCap -1 = 31
                    xxxx 0101 &
                    ------------
                    000x 0101  所以最左边的x是1, 我们称为高位, x位0 就是低位不动
                       x 是唯一判断高位和地位的 元素
                    0001 0101 高位 16+5 放到新的下标 21
                    0000 0101 低位 5
                    */
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    //拆树 : 麻烦的很 不看
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else {
                    //拆除链表 的方法, 分出高低位两条链. 高位链放高位,低位链下标不变
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        //指针移动
                        next = e.next;
                        //注意没有减一, 直接判断高位
                        /*
                        oldCap = 16
                        0001 0000 
                        xxxx xxxx &
                        -----------
                        000x 0000 直接判断高位x  x=0 就是低位
                        */
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null){
                                //低位头节点赋值
                                loHead = e;
                            }
                            //非第一次进入  后续都是进这个
                            else{
                                loTail.next = e;
                            }
                            //低位尾节点赋值
                            loTail = e;
                        }
                        else {
                            //高位处理 第一次
                            if (hiTail == null)
                                hiHead = e;
                            else //后续
                                hiTail.next = e;
                            //尾指针往下走
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    //尾节点 断后链
                    if (loTail != null) {
                        loTail.next = null;
                        //j=5 下标不变 存入新数组
                        newTab[j] = loHead;
                    }
                    //尾节点 断后链
                    if (hiTail != null) {
                        hiTail.next = null;
                        //下标怎么算的 ? 5 + 16 =21新下标
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

![image-20250417170733433](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504171707694.png)

> HashMap的新增方法，跳过了 红黑树相关的内容。

### 6. 删除方法：

> HashMap的删除方法：首先根据key的hash值找到对应的桶，然后遍历链表或红黑树，找到匹配的节点进行删除。

```java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        //插入的元素通过Hash计算后，快速定位到 目标桶的位子，就可以不用遍历数组，只需要遍历链表
        (p = tab[index = (n - 1) & hash]) != null) {
        Node<K,V> node = null, e; K k; V v;
        //判断头节点?
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            node = p;
        //遍历，看头节点的下一个节点是否为空
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                //红黑树的查询方法
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            else {
                //就是遍历链表，看有没有相同的key
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        //如果找到目标节点后
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            //树删除
            if (node instanceof TreeNode)
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            //节点的删除方法
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
```

### 7. 修改方法

> 你猜，HashMap是怎么修改的？是用的put方法来更新的。
>
> 1.先根据Hash值找到桶
>
> 2.遍历桶下的链表，当Hash值和key值相同的时候，才会直接替换value即可。
>
> 3.如果树节点，那就遍历树替换value。

### 8. 查询方法

![image-20250418104443728](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504181044000.png)

## 四、常见Hash面试题

### 1. HashMap和HashTable的区别

1. **线程安全性**：
   - **HashMap**：非线程安全。在多线程环境下，如果多个线程同时访问并修改HashMap，可能会导致数据不一致或者出现并发问题。
   - **HashTable**：线程安全。HashTable的所有公共方法都是同步的，使用内部锁机制来保证多线程环境下的线程安全。

2. **性能**：
   - **HashMap**：由于不需要考虑线程同步的问题，HashMap的性能通常比HashTable高。
   - **HashTable**：由于所有操作都是同步的，线程安全性带来了性能上的开销，**因此在单线程环境下，HashTable的性能不如HashMap**。（性能区别不大的，锁升级过程。JDK5之前是对的，之后这句话就不对了）

3. **Null值处理**：
   - **HashMap**：允许使用一个null键和多个null值。
   - **HashTable**：不允许使用null键和null值，尝试插入null键或值会抛出NullPointerException。
   - ![image-20250418104909871](https://woniumd.oss-cn-hangzhou.aliyuncs.com/security/mayuhang/202504181049151.png)

4. **迭代器**：
   - **HashMap**：迭代器是快速失败的，这意味着在迭代过程中如果检测到HashMap结构发生变化（如添加、删除元素），会立即抛出ConcurrentModificationException。
   - **HashTable**：迭代器不是快速失败的，可以在迭代过程中修改集合。

5. **继承关系**：
   - **HashMap**：继承自AbstractMap类。
   - **HashTable**：继承自Dictionary类，同时实现了Map接口。

6. **使用场景**：
   - **HashMap**：适用于单线程环境或者外部进行同步控制的情况。
   - **HashTable**：适用于多线程环境，需要内部同步的情况。

7. **初始容量和加载因子**：
   - **HashMap**：默认初始容量为16，加载因子为0.75。
   - **HashTable**：默认初始容量为11，加载因子为0.75。

总结来说，HashMap在现代Java开发中更为常用，因为它提供了更好的性能和更灵活的null值处理。而HashTable由于其线程安全性，在一些需要同步操作的场景下仍有其应用价值。不过，在多线程环境下，更推荐使用ConcurrentHashMap，它提供了更好的并发性能和更丰富的并发操作支持。

比如: 1. 线程安全性：HashMap是非线程安全的，而HashTable是线程安全的。



### 2. HashSet的源码

#### 1. 先看继承关系

```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
```

#### 2. 看构造方法

```java
public HashSet() {
    map = new HashMap<>();
}
```

#### 3. 看新增方法

```java
public boolean add(E e) {
    //PRESENT new Object()
    return map.put(e, PRESENT)==null;
}
```

发现，HashSet使用的仅仅只是HashMap的key，而value则全部都是同一个Object对象



### 3. Hash扩展延伸知识

#### 1. Nginx的负载均衡算法

策略：UrlHash , Iphash。



#### 2. redis里面

Set，Zset类型。 有Hash的特性在。才会是无序。

Hash槽，redis集群的解决方案。65535. 2的16次方 2^16次方



因为Hash槽,引出一致性Hash算法, 为啥redis集群,不用一致性Hash?



#### 3. ThreadLocal

这个讲线程再不充.hash槽的角度讲

#### 4. ConcurrentHashMap

也在并发JUC环节讲解.
