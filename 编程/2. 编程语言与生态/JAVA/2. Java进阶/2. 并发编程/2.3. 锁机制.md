
# 一.  synchronized的三种应用方式

synchronized关键字最主要有以下3种应用方式

- 修饰**实例方法**，作用于当前**实例加锁**，进入同步代码前要获得**当前实例的锁**
- 修饰**静态方法**，作用于当前**类对象加锁**，进入同步代码前要获得**当前类对象的锁**
- 修饰**代码块**，**指定加锁对象**，对给定对象加锁，进入同步代码库前要获得**给定对象的锁**。


# 二.  同步代码块(灵活)

### 1. **线程同步**机制的语法是：

```java
synchronized(同步锁)
{
     //线程同步代码块
} 
```

`synchronized`后面的小括号中传的这个 **“数据”是相当关键** 的  
这个数据必须是**多线程共享**的数据。才能达到线程排队。

### 2. **`（）` 中具体写什么？**

那要看想**让哪些线程同步**。  
假设t1、t2、t3、t4、t5，有5个线程。现在只希望t1、t2、t3排队，t4、t5不需要排队。  
这时就要在 `()` 中写一个t1、t2、t3共享的对象，而这个对象对于t4、t5来说不是共享的。

```java
//this,当前实例对象锁
synchronized(this){
    for(int j=0;j<1000000;j++){
        i++;
    }
}

//class对象锁
synchronized(AccountingSync.class){
    for(int j=0;j<1000000;j++){
        i++;
    }
}
```

**在java语言中,任何一个对象都有“一把锁”,其实这把锁就是标记。( 只是把它叫做锁。)  
100个对象, 10把锁。1个对象1把锁。**

### 3. 线程同步的代码的执行原理 ?

1. 假设t1和t2线程并发,开始执行以下代码的时候，肯定有一个先一个后。

2.  假设t1先执行了,遇到了 `synchronized` ,这个时候自动找“后面共享对象”的对象锁,找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一直都是占有这把锁的。直到同步代码块代码结束,这把锁才会释放。

3. 假设t1已经占有这把锁,此时2也遇到 `synchronized` 关键字,也会去占有后面共享对象的这把锁,结果这把锁被t1占有, t2只能在同步代码块外面等待t1的结束,直到t1把同步代码块执行结束了, t1会归还这把锁，此时t2终于等到这把锁,然后t2占有这把锁之后，进入同步代码块执行程序。

这样就达到了线程排队。


# 三.  synchronized作用于实例方法

被修饰的方法称为**同步方法**，其作用的**范围是整个方法**，作用的**对象是调用这个方法的对象**；

如果**多个线程访问同一个对象的实例变量**，可能出现**非线程安全**问题。

使用 `synchronized` 修饰的方法, 就叫做**同步方法**, 保证 **A 线程执行**该方法的时候 ,**其他线程只能在方法外等着**. 且**共享对象一定是 this**，并且**同步代码块是整个方法体**。

```java
synchronized public  void  doWork(){

	//  需要同步操作的代码
}
```

**创建了一个AccountingSync对象:**

```java
public class AccountingSync implements Runnable{
    //共享资源(临界资源)
    static int i=0;

    /**
     * synchronized 修饰实例方法
     */
    public synchronized void increase(){
        i++;
    }
    @Override
    public void run() {
        for(int j=0;j<1000000;j++){
            increase();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        AccountingSync instance=new AccountingSync();
        Thread t1=new Thread(instance);
        Thread t2=new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(i);
    }
}
```

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418180756027.png)


# 四.  synchronized作用于静态方法

表示找**类锁**。类锁永远只有一把。就算创建了 100 个对象，那类锁也只有一把。

- 对象锁：1 个对象 1 把锁，100 个对象 100 把锁。
- 类锁：100 个对象，也可能只是 1 把类锁。

当 synchronized 作用于静态方法时，其锁就是当前类的 class 对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过 class 对象锁可以控制静态成员的并发操作。需要注意的是如果一个线程 A 调用一个实例对象的非 static synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的 class 对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁，看如下代码

**创建了两个AccountingSyncClass对象：**

```java
public class AccountingSyncClass implements Runnable{
    static int i=0;

    /**
     * 作用于静态方法,锁是当前class对象,也就是
     * AccountingSyncClass类对应的class对象
     */
    public static synchronized void increase(){
        i++;
    }

    @Override
    public void run() {
        for(int j=0;j<1000000;j++){
            increase();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        //new新实例
        Thread t1=new Thread(new AccountingSyncClass());
        //new心事了
        Thread t2=new Thread(new AccountingSyncClass());
        //启动线程
        t1.start();t2.start();

        t1.join();t2.join();
        System.out.println(i);
    }
}
```

![image.png|475](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418180856995.png)

由于 synchronized 关键字修饰的是静态 increase 方法，与修饰实例方法不同的是，其锁对象是当前类的 class 对象。注意代码中的 increase 4 Obj 方法是实例方法，其对象锁是当前实例对象，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题 (操作了共享静态变量 i)。


# 五.  Java三大变量的线程安全

- **实例变量:在堆中**。
- **静态变量:在方法区**。
- **局部变量:在栈中**。

以上三大变量中:

**局部变量**永远都==不会存在线程安全==问题。因为==局部变量不共享==。(一个线程一个栈。)
局部变量在栈中。所以局部变量永远都不会共享。

**实例变量**在堆中，==堆只有 1 个==。

**静态变量**在方法区中，==方法区只有 1 个==。
==堆和方法区都是多线程共享的==，所以可能存在线程安全问题。

**局部变量+常量：不会有线程安全问题。**
**成员变量：可能会有线程安全问题。**


# 六.  死锁概述

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418181247821.png)


```java
public class ThreadTest10 {
    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();
        Thread t1 = new MyThread1(o1,o2);
        Thread t2 = new MyThread2(o1,o2);
        t1.start();
        t2.start();
    }
}
class  MyThread1 extends Thread{
    Object o1;
    Object o2;
    public MyThread1(Object o1,Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }

    @Override
    public void run(){
        synchronized (o1){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized(o2){

            }
        }
    }
}
class MyThread2 extends Thread{
    Object o1;
    Object o2;
    public MyThread2(Object o1,Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }

    @Override
    public void run(){
        synchronized(o2){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1){

            }
        }
    }
}
```

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418181305311.png)

一直是这样，synchronized在开发中最好不要嵌套使用。一不小心就会导致死锁现象的发生。