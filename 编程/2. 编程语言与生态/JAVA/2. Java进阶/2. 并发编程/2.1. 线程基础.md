
# 一. 多线程

## 1.  什么是进程?什么是线程?

**进程**是一个**应用程序**(1个进程是一个软件)。

**线程**是一个**进程中的执行场景/执行单元**。

**一个进程可以启动多个线程。**

> 对于java程序来说，当在DOS命令窗口中输入:
> java HelloWorld 回车之后。会先启动JVM，而JVM就是一个进程。
> JVM再启动一个主线程调用main方法.同时再启动一个垃圾回收线程负责看护，回收垃圾。
> 最起码，现在的java程序中至少有两个线程并发，
> 一个是垃圾回收线程，一个是执行main方法的主线程.


##  2.  进程和线程是什么关系?举例

> 阿里巴巴：进程  
> 马云：阿里巴巴的一个线程  
> 童文红：阿里巴巴的一个线程

> 京东：进程  
> 强东：京东的一个线程  
> 妹妹：京东的一个线程

进程可以看做是现实生活中的公司。

线程可以看做是公司当中的某个员工。

注意：进程A和进程B的内存独立不共享。（阿里和京东的资源不会共享）  
魔兽游戏是一个进程  
酷狗音乐是一个进程  
这两个进程是独立的，不共享资源。

**线程A和线程B呢?**

- 在java语言中:  
    线程A和线程B，**堆内存和方法区内存共享**。  
    但是**栈内存独立**，**一个线程一个栈**。

假设启动10个线程，会有10个栈空间，每个栈和每个栈之间，互不干扰，各自执行各自的，这就是多线程并发。

> 火车站，可以看做是一个进程。  
> 火车站中的每一个售票窗口可以看做是一个线程。  
> 我在窗口1购票，你可以在窗口2购票，你不需要等我，我也不需要等你,所以多线程并发可以提高效率。

java中之所以有多线程机制，目的就是为了**提高程序的处理效率**。

## 3.  使用了多线程机制之后，main方法结束，有可能程序也不会结束

因为main方法结束只是主线程结束了，主栈空了，其它的栈(线程)可能还在压栈弹栈。

![image.png|675](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418173128837.png)

# 二.  多线程并发的理解

**分析一个问题:对于单核的CPU来说，真的可以做到真正的多线程并发吗?**

对于多核的CPU电脑来说，真正的多线程并发是没问题的。  
4核CPU表示同一一个时间点上，可以真正的有4个进程并发执行。

**什么是真正的多线程并发?**

t1线程执行t1的。  
t2线程执行t2的。  
**t1不会影响t2，t2也不会影响t1**.这叫做真正的**多线程并发**。

**单核的CPU表示只有一个大脑**:

不能够做到真正的多线程并发，但是可以做到给人一种=="多线程并发"的感觉==。对于单核的 CPU 来说，在某一个时间点上实际上只能处理一件事情，但是由于 CPU 的处理速度极快，==多个线程之间频繁切换执行==，跟人来的感觉是: 多个事情同时在做!!!

线程 A: 播放音乐
线程 B: 运行魔兽游戏

线程 A 和线程 B 频繁切换执行，人类会感觉音乐一直在播放，游戏一直在运行,
给我们的感觉是同时并发的。

> 电影院采用胶卷播放电影，一个胶卷一个胶卷播放速度达到一定程度之后，人类的眼睛产生了错觉，感觉是动画的。这说明人类的反应速度很慢，就像一根钢针扎到手上，到最终感觉到疼，这个过程是需要"很长的"时间的，在这个期间计算机可以进行亿万次的循环。所以计算机的执行速度很快。


# 三.  线程的生命周期

- 1.新建状态
- 2.就绪状态
- 3.运行状态
- 4.阻塞状态
- 5.死亡状态

![image.png|750](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418174306398.png)


# 四.  实现线程的方式

## 1.  继承java.lang.Thread,重写run方法

实现线程的第一种方式：  
**编写一个类直接继承`java.lang.Thread`,重写run方法。**

怎么**创建线程对象**？**new就行了**

怎么**启动线程**呢？**调用线程对象的 `start()` 方法就行**

```java
public class ThreadTest01 {
    public static void main(String[] args) {
        //这里是一个main方法，这里的代码属于主线程，在主栈中运行。
        //新建一个分支线程对象
        MyThead myThead = new MyThead();
        //启动线程

        //myThead.run();//不会启动线程，不会分配新的分支栈。（这种方式就是单线程）

        //start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码的任务完成之后，瞬间就结束了。
        //这段代码的任务只是为了开辟一个新的栈空间，只要新的栈空间开辟出来，start()方法就结束了。线程就启动成功了。
        //启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）
        //run方法在分支栈的栈底部，main方法在主栈的底部。run和main是平级的。
        myThead.start();//这行代码是瞬间结束的
        //这里的代码还是运行在主线程中
        for (int i = 0; i < 1000; i++) {
            System.out.println("主线程-->" + i);
        }
    }
}
class MyThead extends Thread{
    @Override
    public void run() {   //必须写
        for (int i = 0; i < 1000; i++) {
            System.out.println("分支线程-->" + i);
        }
    }
}
```

**运行结果：**

![image.png|227](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418174504875.png)

**未注释run()方法的运行结果，此时不是并发：**

![image.png|220](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418174520861.png)

由上述运行结果发现，有以下特点：**有先有后、有多有少**。

## 2.  实现java.lang.Runnable接口，实现run方法

实现线程的第二种方式：  
**编写一个类，实现`java.lang.Runnable`,重写run方法。**

这种方式实现接口比较常用，因为一个类实现了接口，它还可以去继承其他的类，更灵活。

```java
public class ThreadTest02 {
    public static void main(String[] args) {
        //创建一个可运行的对象
        MyRunnable myRunnable = new MyRunnable();
        //将可运行的对象封装成一个线程对象
        Thread t = new Thread(myRunnable);
        //启动线程
        t.start();

        for (int i = 0; i < 1000; i++) {
            System.out.println("主线程-->" + i);
        }
    }
}

//这并不是一个线程类，是一个可运行的类。它还不是一个线程。
class MyRunnable implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("分支线程-->" + i);
        }
    }
}
```

## 3.  采用匿名内部类的方式

```java
public class ThreadTest03 {
    public static void main(String[] args) {

        //创建线程对象，采用匿名内部类的方式。
        //这是通过一个没有名字的类，new出来的对象。
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    System.out.println("t线程-->" + i);
                }
            }
        });

        //启动线程
        t.start();

        for (int i = 0; i < 1000; i++) {
            System.out.println("主线程-->" + i);
        }
    }
}
```

## 4.  实现Callable接口（JDK8新特性）

该方法**效率较低**，因为在获取线程的执行结果的时候，当前线程受阻塞。但是可以拿到**线程的返回结果**

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class ThreadTest12 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //第一步：创建一个“未来任务类”接口
        FutureTask task = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception {//call方法就相当于run方法。只不过这个有返回值
                //线程执行一个任务，执行之后可能会有一个执行结果
                //模拟执行
                System.out.println("call method begin!");
                Thread.sleep(1000 * 10);
                System.out.println("call method end!");
                int a = 100;
                int b = 200;

                return a + b;//自动装箱（300结果变成Integer）
            }
        });

        //创建线程对象
        Thread t = new Thread(task);

        //启动线程
        t.start();

        //这里是main方法，这是在主线程中
        //在主线程中，怎么获取t线程的返回结果？
        //get发方法的执行会导致“当前线程阻塞”
        Object o = task.get();
        System.out.println("线程执行结果：" + o);

        //main方法这里的程序想执行必须等待get()方法的结束
        //而get()方法是为了拿另一个线程的执行结果
        //另一个线程执行是需要时间的
        System.out.println("hello world!");
    }
}
```

运行结果：

![image.png|475](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418174658669.png)


# 五.  获取、修改线程对象的名字

**获取当前线程对象**：`static Thread currentThread()`

```java
Thread t = Thread.currentThread();//返回值t就是当前线程
```

```java
public class ThreadTest04 {
    public static void main(String[] args) {
        //创建线程对象
        MyThead2 t = new MyThead2();
        //设置线程的名字
        t.setName("t1");
        //获取线程的名字
        t.getName();
        //启动线程
        t.start();
        String tName = t.getName();
        System.out.println(tName);


        MyThead2 t2 = new MyThead2();
        t2.setName("t2");
        String t2Name = t2.getName();
        System.out.println(t2Name);

        t2.start();
    }
}

class  MyThead2 extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
        	//currentThread就是当前线程对象。
        	//当t1线程执行run方法，那么这当前线程就是t1；
        	//当t2线程执行run方法，那么这当前线程就是t2；
            Thread currentThread = Thread.currentThread();
            System.out.println( currentThread.getName() + "-->" + i);
        }
    }
}
```

运行截图：

![image.png|200](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418175014843.png)


**获取线程对象的名字**：`String name = 线程对象.getName();`

**修改线程对象的名字**：`线程对象.setName("线程名字");`

当线程没有设置名字的时候，**默认的名字有什么规律**？  
Thread-0；  
Thread-1；  
Thread-2…

```java
public class ThreadTest04 {
    public static void main(String[] args) {
        //创建线程对象
        MyThead2 t = new MyThead2();
        //设置线程的名字
        t.setName("tttt");
        //获取线程的名字
        t.getName();
        //启动线程
        t.start();

        String tName = t.getName();
        System.out.println(tName);//如果不设置线程的名字就是：Thread-0

        MyThead2 t2 = new MyThead2();
        System.out.println(t2.getName());//Thread-1
    }
}

class  MyThead2 extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("分支线程-->" + i);
        }
    }
}
```

运行结果：

![|262](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418175050475.png)


# 六.  线程中的sleep方法详解

## 1.  关于线程的sleep方法

`static void sleep(long mills)`

- 1、**静态方法**：Thread.sleep(1000);
- 2、参数是**毫秒**
- 3、作用：**让当前线程进入休眠，进入“阻塞”状态，放弃占有CPU时间片，让给其他线程使用**。

```java
public class ThreadTest06 {
    public static void main(String[] args) {
        //让当前线程进入休眠，睡眠5秒
        //当前线程是主线程！！!
        try {
            Thread.sleep(1000*5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

		//5秒之后执行这里的代码
        System.out.println("hello world!");
    }
}
```

## 2.  分析哪个线程休眠的

以下代码是让**main方法休眠**的

```java
public class ThreadTest06 {
    public static void main(String[] args) {
        Thread t = new MyThread();
        t.setName("t");
        t.start();
        //调用sleep方法
        try {
            //
            t.sleep(1000*5);//在执行过程中还是会被转换为：Thread.sleep(1000*5);
            //这行代码的作用是：让当前的线程进入休眠，也就是说说main线程进入休眠。
            //这样代码出现在main方法中，main线程休眠。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("hello world!");
    }
}
class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println(Thread.currentThread().getName() + "-->" + i);
        }
    }
}
```

## 3.  终止线程的休眠

sleep睡眠太久了，如果希望半道上醒来，可以使用`interrupt()`方法  
注意：这个**不是终断线程的执行，是终止线程的睡眠**

```java
public class ThreadTest07 {
    public static void main(String[] args) {

        Thread t = new Thread(new MyRunable2());
        t.setName("t");
        t.start();

        //希望5秒以后，t线程醒来（5秒以后主线程的活干完了）
        try {
            Thread.sleep(1000*5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）
        t.interrupt();//干扰，一盆冷水过去！！
    }
}

class MyRunable2 implements Runnable{
    //重点：run()当中的异常不能throws，只能try..catch
    //因为run()方法在父类中没有抛出异常，子类不能比父类抛出更多异常。
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "--> begin");
        try {
            //睡眠1年
            Thread.sleep(1000*60*60*24*365);
        } catch (InterruptedException e) {
            //打印异常信息
            e.printStackTrace();
        }
        //一年之后才会执行这里
        System.out.println(Thread.currentThread().getName() + "--> end");
    }
}
```

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418175335295.png)

## 4.  终止线程

### 4.1. 强行终止线程

`stop()`方法，有一个很大的缺点：**容易丢失数据**。因为这种方式是直接将线程杀死了。  
**线程没有保存的数据将会丢失。不建议使用。**

### 4.2. 合理的终止线程

**打一个boolean标记**

```java
public class ThreadTest08 {
    public static void main(String[] args) {
        Thread t = new Thread();
        MyRunnable4 r = new MyRunnable4();
        t.setName("t");
        t.start();

        //模拟5秒
        try {
            Thread.sleep(1000 * 5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //终止线程
        //你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。
        r.run = false;
    }
}
class MyRunnable4 implements Runnable{

    //打一个boolean标记
    boolean run = true;

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            if (run){
                System.out.println(Thread.currentThread().getName() + "-->" + i);
                try {
                    Thread.sleep(1000 );
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }else {
                //return就结束了，在结束之前还有什么没有保存的。
                //可以在这里保存
                //save....
                return;
            }
        }
    }
}
```


# 七.  线程的调度

## 1.  常见的线程调度模型有哪些?

- **抢占式调度模型**:  
    哪个线程的**优先级比较高**，抢到的**CPU时间片的概率就高**一些/多一些。  
    **java采用的就是抢占式调度模型**。
- **均分式调度模型:**  
    平均分配CPU时间片。**每个线程占有的CPU时间片时间长度一样**。  
    平均分配，一切平等。  
    有一些编程语言，线程调度模型采用的是这种方式。


## 2.  java中提供了哪些方法是和线程调度有关系的呢?

- 1、实例方法:
	`void setpriority (int newPriority)`：==设置线程的优先级==
	`int getPriority ()`：==获取线程优先级==
	最低优先级 1
	默认优先级是 5
	最高优先级 10

- 2、静态方法:
	`static void yield ()`：==让位方法：暂停当前正在执行的线程对象，并执行其他线程==
	
`yield ()` 方法不是阻塞方法。让当前线程让位，让给其它线程使用。
`yield () ` 方法的执行会让当前线程从“运行状态”**回到**“就绪状态”**。
注意：在回到就绪之后，有可能还会再次抢到 CPU

- 3、实例方法：
	`void join () `：==合并线程==

```java
class MyThread1 extends Thread {
		public void doSome(){
			Mythread2 t = new MyThread2();
			t,join();//当前线程进入阻塞，t线程执行，知道t线程结束。当前线程才可以继续
		} 	
}
class MyThread2 extends Thread{
}
```

# 八.  线程优先级

1.  `int getPriority()`：**获取线程优先级**

```java
public class ThreadTest09 {
    public static void main(String[] args) {
        System.out.println("最高优先级" + Thread.MAX_PRIORITY);
        System.out.println("最低优先级" + Thread.MIN_PRIORITY);
        System.out.println("默认优先级" + Thread.NORM_PRIORITY);

        //获取当前线程对象，获取当前线程的优先级
        Thread currentThread = Thread.currentThread();
        System.out.println(currentThread.getName() + "线程的默认优先级为：" + currentThread.getPriority());

        Thread t = new Thread(new MyRunnable5());
        t.setName("t");
        t.start();
    }
}

class MyRunnable5 implements Runnable{
    @Override
    public void run() {
        //获取线程优先级
        System.out.println(Thread.currentThread().getName() + "线程的默认优先级为" + Thread.currentThread().getPriority());
    }
}
```

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418175917739.png)


2.  `void setpriority (int newPriority)`：**设置线程的优先级**

```java
public class ThreadTest09 {
    public static void main(String[] args) {

        //设置主线程优先级为1
        Thread.currentThread().setPriority(1);
        //获取当前线程对象，获取当前线程的优先级
        Thread currentThread = Thread.currentThread();
        Thread t = new Thread(new MyRunnable5());
        t.setName("t");
        t.setPriority(10);
        t.start();

        //优先级较高的，只是抢到的CPU的时间片比较多一些。
        //大概率方向更偏向于优先级比较高的。
        for (int i = 0; i < 10000; i++) {
            System.out.println(Thread.currentThread().getName() + "-->" + i);
        }
    }
}

class MyRunnable5 implements Runnable{
    @Override
    public void run() {

        for (int i = 0; i < 10000; i++) {
            System.out.println(Thread.currentThread().getName() + "-->" + i);
        }
    }
}
```

![image.png|183](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418175949057.png)


# 九.  线程让位

**让位：值当前的线程暂停，回到就绪状态，让给其他线程。**  
静态方法：`Thread.yield();`

```java
public class ThreadTest09 {
    public static void main(String[] args) {

        Thread t = new Thread(new MyRunnable5());
        t.setName("t");
        t.start();

        for (int i = 1; i < 10000; i++) {
            System.out.println(Thread.currentThread().getName() + "-->" + i);
        }
    }
}

class MyRunnable5 implements Runnable{
    @Override
    public void run() {
        for (int i = 1; i <= 10000; i++) {
            //每100个让位一次
            if (i % 100 == 0){
                Thread.yield();
            }
            System.out.println(Thread.currentThread().getName() + "-->" + i);
        }
    }
}
```

# 十.  线程合并

线程的合并的含义就是**将几个并行线程的线程合并为1个单线程执行**。应用场景应该是**一个线程必须等待另一个线程执行完毕才能使用join方法。**

```java
public class ThreadTest09 {
    public static void main(String[] args) {

        System.out.println("main begin");

        Thread t = new Thread(new MyRunnable5());
        t.setName("t");
        t.start();

        //合并线程
        try {
            t.join();//t合并到当前的线程中，当前线程受阻塞，t线程执行直到结束再继续执行main线程。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("main over");
    }
}

class MyRunnable5 implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            System.out.println(Thread.currentThread().getName() + "-->" + i);
        }
    }
}
```

![image.png|346](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418180044013.png)


# 十一.  守护线程

## 1.  守护线程概述

Java语言中线程分为两大类：

- 一类是：**用户线程**
- 一类是：**守护线程（后台线程）**

其中具有代表性的就是：**垃圾回收线程（守护线程）**、**主线程main（用户线程）**

**守护线程的特点：**  
一般守护线程是一个死循环，所有的用户只要结束，守护线程自动结束。

**守护线程用在什么地方呢？**  
每天00:00的时候系统数据自动备份。这个需要使用到定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，每到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。

## 2.  实现守护线程

```java
在这里插入代码片public class ThreadTest11 {
    public static void main(String[] args) {

        Thread t = new BakDataThread();
        t.setName("备份数据的线程");

        //启动线程之前，将线程设置为守护线程
        t.setDaemon(true);
        t.start();

        //主线程：主线程是用户线程
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + "-->" + i) ;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
class BakDataThread extends Thread{
    @Override
    public void run(){
        int i = 0;
        while (true){
            System.out.println(Thread.currentThread().getName() + "-->" + (++i));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}
```

**运行结果：主线程结束，守护线程就结束，即使是个死循环。**

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418181503077.png)

# 十二.  定时器

## 1.  定时器概述

定时器的作用:  
**间隔特定的时间，执行特定的程序。**

> 例如每周要进行银行账户的总账操作。  
> 每天要进行数据的备份操作。

在实际的开发中，每隔多久执行一-段特定的程序，这种需求是很常见的,  
那么在java中其实可以采用多种方式实现:

- 可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行任务。这种方式是最原始的定时器。(比较low)

- 在java的类库中已经写好了一个定时器: `java. util.Timer`,可以直接拿来用。不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的。

- 在实际的开发中，目前使用较多的是**Spring框架中提供的springTask**框架,  
    这个框架只要进行简单的配置，就可以完成定时器的任务。


## 2.  实现定时器

`timer.schedule(定时任务，第一次执行时间，间隔多久执行一次);`  
**也可以使用匿名内部类设定定时任务**

```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class TimerTest {
    public static void main(String[] args) throws Exception{
        //创建定时器对象
        Timer timer = new Timer();
        //Timer timer = new Timer(true);//守护线程的方式

        //指定定时任务
        //timer.schedule(定时任务，第一次执行时间，间隔多久执行一次);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date firstTime = sdf.parse("2021-3-17 11:24:30");
        timer.schedule(new LogTimerTask(),firstTime,1000*10);
    }
}
//编写一个类
//假设这是一个记录日志的定时任务
class LogTimerTask extends TimerTask{
    @Override
    public void run() {
        //编写需要执行的任务就行了。
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String strTime = sdf.format(new Date());
        System.out.println(strTime +":成功完成第一次数据备份！");
    }
}
```

运行结果：

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418181650762.png)
