
# 一. 泛型机制

泛型机制只在程序编译阶段起作用，只是给编译器参考的。（**运行阶段泛型没有用！**）

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class GenericText {
    public static void main(String[] args) {
        //使用泛型机制
        //使用泛型List<Animal>之后，表示List集合中只允许存储Animal类型的数据
        //用泛型来指定集合中存储的数据类型
        List<Animal> myList =new ArrayList<Animal>();

        //指定List集合中只能存储Animal，那么存储String就编译报错了
        //这样用了泛型之后，集合中元素的数据类型更加统一了。
        //myList.add("abc")

        Cat c = new Cat();
        Bird b = new Bird();
        myList.add(c);
        myList.add(b);

        //获取迭代器
        //这个表示迭代器迭代的是Animal类型
        Iterator<Animal> it = myList.iterator();
        while (it.hasNext()){
            //使用泛型之后，每一次迭代返回的数据都是Animal类型。
            Animal a = it.next();
            //这里不需要进行强制类型转换了。直接调用
            a.move();

        }


    }
}

class Animal {
    //父类自带的方法
    public void move(){
        System.out.println("动物在移动");
    }
}

class Cat extends Animal{
    //特有方法
    public void catchMouse(){
        System.out.println("猫抓老鼠");
    }
}

class Bird  extends Animal{
    //特有方法
    public void fly(){
        System.out.println("鸟儿在飞翔");
    }
}
```

**运行结果：**

![image.png|248](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418144529792.png)


**调用子类型特有的方法还是需要向下转换的！**

```java
//调用子类型特有的方法还是需要向下转换的！
Animal a = it.next();
if(a instanceof Cat){
    Cat x = (Cat) a;
    x.catchMouse();
}
if (a instanceof Bird){
    ((Bird) a).fly();
}
```

**运行结果：**

![image.png|199](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418144552519.png)


## 1.  泛型的好处

- 第一：集合中存储的**元素统一**了。
- 第二：从集合中取出的元素类型是**泛型指定的类型**，不需要进行大量的“**向下转型**”

## 2.  泛型的缺点

导致集合中存储的元素**缺乏多样性**。

**大多数业务中，集合中元素的类型还是统一的。所以这种泛型特性被大家认可。**

# 二.  类型自动推断

JDK之后引入了：`自动类型转换推断机制`(又称钻石表达式)  
`ArrayList< 这里的类型会自动推断 >()`,，前提是JDK8之后才允许

```java
//自动类型推断，钻石表达式 
List<Animal> myList = new ArrayList<>(); 
```

# 三.  自定义泛型

自定义泛型的时候 , <> 尖括号中的是一个标识符，随便写。  
Java源代码中经常出现的是：  
`<E>` 和`<T>`

- `<E>`是Elements单词首字母：**元素**
- `<T>` 是Type单词首字母：**类型**

```java
public class GenericText1<标识符随便写> {
    public void doSome(标识符随便写 o){
        System.out.println(o);
    }

    public static void main(String[] args) {

        //new对象的时候指定了泛型是：String类型
        GenericText1<String> gt = new GenericText1<>();
        gt.doSome("abc");
        
        //类型不匹配
        //gt.doSome(123);

        GenericText1<Integer> gt2 =new GenericText1<>();
        gt2.doSome(100);

        //类型不匹配
        //gt.doSome("abc");

        MyIterator<String> mi = new MyIterator<>();
        String s1 = mi.get();

        MyIterator<Animal> mi2 = new MyIterator<>();
        Animal s2 = mi2.get();
        
        //不用泛型就是Object类型
        GenericText1 gt3 =new GenericText1();
        gt3.doSome(new Object());
    }
}

class MyIterator<T>{
    public T get(){
        return null;
    }
}
```
