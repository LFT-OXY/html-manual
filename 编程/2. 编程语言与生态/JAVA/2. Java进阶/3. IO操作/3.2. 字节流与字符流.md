
# 一.  FileInputStream

`java.io.FileInputStream`:  
1、文件字节流，万能的，任何类型的文件都可以采用这个流来读。  
2、字节的方式，完成输入的操作，完成读的操作（硬盘–>内存）

## 1.   `int read()` ：从此输入流中读取一个数据字节

**示例代码1：**

```JAVA
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileInputStreamtest1 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            //创建文件字节输入流对象
            fis = new FileInputStream("C:\\Users\\Administrator\\Desktop\\temp.txt");

            //开始读
            int readData = fis.read();//这个方法的返回值是：读取到的“字节”方法本身
            System.out.println(readData);//97

            readData = fis.read();
            System.out.println(readData);//98

            readData = fis.read();
            System.out.println(readData);//99

            readData = fis.read();
            System.out.println(readData);//100

            readData = fis.read();
            System.out.println(readData);//101

            readData = fis.read();
            System.out.println(readData);//102

            //已经读到文件的末尾了，在读的时候读取不到任何数据，返回-1
            readData = fis.read();
            System.out.println(readData);// -1

            readData = fis.read();
            System.out.println(readData);//-1


        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //在finally语句块当中确保流一定关闭
            if (fis != null) {
                //关闭流的前提是：流不是空。流是null的时候没必要关闭。
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}
```

**temp文件：**

![image.png|207](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418150721768.png)


**运行结果：**

![image.png|195](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418150734954.png)

**演示：**

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418150752188.png)


**对上一个程序进行改进（使用while循环输出字节）：**

```JAVA
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileInuputStreamtest2 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("C:\\Users\\Administrator\\Desktop\\temp.txt");

            while (true){
                int readData = fis.read();
                if (readData == -1){
                    break;
                }
                System.out.println(readData);
            }
            
			//改造while循环
            int readData = 0 ;
            while ((readData =fis.read())!= -1){
                System.out.println(readData);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //在finally语句块当中确保流一定关闭
            if (fis != null) {
                //关闭流的前提是：流不是空。流是null的时候没必要关闭。
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}
```

**运行结果：**

![image.png|198](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418150816461.png)


## 2.  `int read(byte[] b)` 一次最多读取b.length个字节

减少硬盘和内存的交互，提高程序的执行效率。  
往 `byte[]` 数组当中读

![image.png|375](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418150915753.png)


```JAVA
import java.io.FileInputStream;
import java.io.IOException;

public class FileInputStreamtest3 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            //相对路径的话呢？相对路径一定是从当前所在的位置作为起点开始找！
            //在IDEA中默认的当前路径是哪里？ 工程Project的根就是IDEA的默认当前路径
            fis = new FileInputStream("temp");

            //开始读，采用byte数组，一次读取多个字节。最多读取：数组.length 个字节
            byte[] bytes = new byte[4];//准备一个4个长度的byte数组，一次最多读取4个字节。
            //这个方法的返回值是：读取到的字节数量(不是字节本身)
            int readCount = fis.read(bytes);
            System.out.println(readCount);
            //将字节数组全部转化为字符串
            System.out.println(new String(bytes));
            //不应该全部都转换，应该是读取了多少字节，转换多少个
            System.out.println(new String(bytes,0,readCount));

            readCount = fis.read(bytes);//第二次只能读取到2个字节
            System.out.println(readCount);//2
            System.out.println(new String(bytes));
            System.out.println(new String(bytes,0,readCount));

            readCount = fis.read(bytes);//第三次1个字节都没有读取到返回-1
            System.out.println(readCount);//-1
            System.out.println(new String(bytes));

        }catch (IOException e){
            e.printStackTrace();
        }finally {
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**运行结果：**

![image.png|181](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418150936861.png)

改进后（while循环）：

```JAVA
import java.io.FileInputStream;
import java.io.IOException;

public class FileIuputStreamtest4 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("temp");
            byte[] bytes = new byte[4];
            while(true){
                int readCount = fis.read(bytes);
                if (readCount == -1){
                    break;
                }
                System.out.print(new String(bytes,0, readCount));
            }
或
			/*
			int readCount1 = 0;
            while ((readCount1 = fis.read(bytes))!= -1){
                System.out.print(new String(bytes,0,readCount1));
            }
            */

        }catch (IOException e){
            e.printStackTrace();
        }finally {
            if (fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }
}
```

**运行结果：**

![image.png|475](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151007524.png)


## 3.  `int available()` :返回流当中剩余的没有读到的字节数量

**在上述代码的前提下进行修改：**

```JAVA
fis = new FileInputStream("temp");
System.out.println("总字节数量" + fis.available());
//读取1个字节
int readByte = fis.read();

System.out.println("剩下多少字节没有读：" + fis.available());
```

**运行结果：**

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151038976.png)

也可采用以下方法输出文件（不适合太大的文件，因为 `byte[]` 数组不能太大）

```JAVA
byte[] bytes = new byte[fis.available()];
System.out.println(fis.read(bytes));
System.out.println(new String(bytes));
```

运行结果：

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151113765.png)


## 4.  `long skip(long n )`:跳过几个字节不读

**修改以上代码：**

```JAVA
fis.skip(3);
System.out.println(fis.read());//不跳过应该是97,现在是100
```

**运行结果：**

![image.png|350](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151144987.png)


# 二.  FileOutputStream

**文件字节输出流，负责写**。

**从内存到硬盘。**

## 1.  输入字节到文件

这种方式将字节**输出到文件**中（但是谨慎使用，这种方式会**将原文件清空**，然后**重新写入**）：

```java
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamtest1 {
    public static void main(String[] args) {
        FileOutputStream fos = null;
        try {
            //myfile文件不存在的时候会自动新建
            fos = new FileOutputStream("myfile");
            //开始写
            byte[] bytes = {97,98,99,100,101,102};
            //将byte数组全部写出！
            fos.write(bytes);
            //将byte数组的一部分写出
            fos.write(bytes,0,2);
            //写完之后，一定要刷新
            fos.flush();

            }catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch(IOException e){
            e.printStackTrace();
        }finally {
            if (fos != null){
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

运行结果：

![image.png|475](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151244672.png)


**以追加的方式在文件末尾写入。不会清空原文件内容：**  
只需在后面加true，即可拼接

```java
fos = new FileOutputStream("myfile",true);
```

**运行结果：**

![image.png|456](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151308491.png)


## 2.  输入字符串到文件

```java
String s = "我是任义";
byte[] bs = s.getBytes();
fos.write(bs);
```

输出结果：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151349401.png)

# 三. 使用FileInputStream+FileOutputStream完成文件拷贝

拷贝的过程是一边读一边写。  
使用以上的字节流拷贝文件的时候，文件类型随意，万能的。什么样的文件都能拷贝

![image.png|425](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151425880.png)


```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class Copy01 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            //创建一个输入流
            fis = new FileInputStream("C:\\Users\\Administrator\\Desktop\\简历.txt");
            //创建一个输出流
            fos = new FileOutputStream("D:\\简历.txt");

            //最核心的：一边读，一边写
            byte[] bytes = new byte[1024*1024];//1MB(一次最多拷贝1MB)
            int readCount = 0;
            while ((readCount = fis.read(bytes))!= -1){
                fos.write(bytes,0,readCount);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            if (fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            if (fos !=null){
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            }
        }
    }
}
```

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151443975.png)

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418151452945.png)


# 四.  FileReader

文件字符输入流，只能读取普通的文本，  
读取普通文本内容时，比较方便，快捷。

```java
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class FileReadertest1 {
    public static void main(String[] args) {
        FileReader reader = null;

        try {
            //创建文件字符输入流
            reader = new FileReader("temp");
            //开始读
            char[] chars= new char[4];//一次读取4个字符
            int readCount = 0;
            while ((readCount = reader.read(chars)) != -1){
                System.out.print(new String(chars,0,readCount));
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**运行结果：**

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418165515520.png)


# 五.  FileWriter

文件字符输出流。

只能输出普通文本

**write的三种构造方法：**

```java
import java.io.FileWriter;
import java.io.IOException;

public class FileWritertest {
    public static void main(String[] args) {
        FileWriter out = null;
        try {
            //创建文件字符输出流对象
            out = new FileWriter("file");//如果想拼接字符，在后面加上true
            //开始写
            char[] chars = {'我','是','中','国','人'};
            out.write(chars);
            out.write(chars,2,3);// 2：起始下标、3：长度
            
            out.write("我是一名Java软件攻城狮");
            out.write("\n");//换行
            out.write("hello world!");
            //刷新
            out.flush();

        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**运行结果：**

![image.png|400](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418165556769.png)

# 六.  复制普通文本文件

```java
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CopyTest2 {
    public static void main(String[] args) {
        FileReader in =null;
        FileWriter out = null;
        try {
       		//读
            in = new FileReader("C:\\Users\\Administrator\\Desktop\\简历.txt");
            //写
            out = new FileWriter("D:\\copy简历.txt");

            char[] chars = new char[1024*512];//1MB
            //一边读一边写
            int readCount = 0;
            while ((readCount = in.read(chars)) != -1){
                out.write(chars,0,readCount);
            }
            //刷新
            out.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (out != null){
                    try {
                        out.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```


