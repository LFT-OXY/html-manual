
# 一.  Arrays工具类

## 1. 常用的Arrays工具类

所有的方法都是静态的，直接用类名调用

主要使用的是两个方法：

- 二分法查找 Arrays.BinarySearch (Array arr, int key)
- 排序 Arrays.Sort (Array arr)

要看文档使用，不要死记硬背
需要导入` java. Util. Arrays` 包使用。

更新：
`Arrays.ToString ()` 将数组打印出来，如果直接输出数组将会打印出地址


# 二. contains方法解析

语法格式：`boolean contains (Object o)`

> **判断集合中是否包含某个对象 o**，如果包含返回 true，如果不包含返回 false。

Contain 方法是用来判断`集合`中是否包含某个元素的方法。

那么他的`底层`是怎么判断集合中是否包含某个元素的呢？

> 调用了 **equals 方法**进行比对
> `equals` 方法返回 true，就表示

**所以存放在一个集合中的类型，一定要重写 equals 方法**

**String 对象：**

```java
package com.company.Collection;

import java.util.ArrayList;
import java.util.Collection;

public class CollectionText2 {
    public static void main(String[] args) {
        //创建集合对象
        Collection c = new ArrayList();

        //向集合中存储对象
        String s1 = new String("abc");
        c.add(s1);

        String s2 = new String("abc");
        c.add(s2);

        //集合中元素的个数
        System.out.println("元素的个数是：" + c.size());

        //新建的对象String
        String x = new String("abc");
        //c集合中是否包含x ？ 结果猜测一下是true还是false ?
        System.out.println(c.contains(x));//判断集合中是否存在“abc” true
    }
}
```

![image.png|450](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418132638800.png)


![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418132649756.png)


**自定义对象：**

```java
package com.company.Collection;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Objects;

public class CollectionText3 {
    public static void main(String[] args) {
        Collection c = new ArrayList();

        //创建用户对象
        User u1 = new User("jack");
        //加入集合
        c.add(u1);

        User u2 = new User("jack");
        System.out.println(c.contains(u2));
    }
}

class  User{
    private String name;
    public User() {
    }
    public User(String name) {
        this.name = name;
    }

	//这个equals方法的比较原理是：只要姓名一样就表示同一个用户
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(name, user.name);
    }
}
```

![image.png|375](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418132737905.png)


# 三. remove方法解析

**在上述代码基础上加入以下该行：**

```java
c.remove(u2);
System.out.println(c.size());//输出结果为：0

Collection cc = new ArrayList();
String s1 = new String("hello");
cc.add(s1);
String s2 = new String("hello");
cc.remove(s2);
System.out.println(cc.size());//输出结果为：0
```

![image.png|375](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418132838477.png)


**去掉User类中的equals方法后，结果为：**

![image.png|250](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418132853190.png)


由此可知remove中也调用了equals方法

### 重点：当集合的结构发生改变的时候，迭代器必须重新获取

**当集合的结构发生改变的时候，迭代器必须重新获取**，如果还是用以前老的迭代器，会出现异常。

```java
Collection c2 = new HashSet();

        Iterator it2 = c2.iterator();
        c2.add(1);
        c2.add(2);
        c2.add(3);
        c2.add(4);
        c2.add(1);
        c2.add(2);
```

此时便会出现异常：  
`ConcurrentModificationException`

```java
package com.company.Collection;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class CollectionText4 {
    public static void main(String[] args) {

        Collection c2 = new ArrayList();
        c2.add("abc");
        c2.add("def");
        c2.add("xyz");

        Iterator it2 = c2.iterator();
        while (it2.hasNext()){
            Object o = it2.next();
            //删除元素
            //删除元素之后，集合的结构发生了变化，应该重新去获取迭代器
            //但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常：ConcurrentModificationException
			//出异常根本原因：集合中元素删除了，但是没有更新迭代器
            c2.remove(o);//直接通过集合删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同）
            System.out.println(o);
        }
    }
}
```

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418132939741.png)


**在迭代集合元素的过程中，不能调用集合对象的 remove 方法，删除元素：`c.remove (o);`**
**迭代过程中不能这样，会出现：`ConcurrentModificationException`**

注意：

> 在**迭代集合元素**的过程当中，一定要使用**迭代器 Iterator 的 remove** 方法，删除元素，不要使用集合自带的 remove 方法删除元素。

可以使用 Iterator 的 remove 方法：

```java
it2.remove();//删除的一定是迭代器指向的当前元素。
```


# 四.  Collections工具类

`java.util.collection`集合接口  
`java.util.Collections` 集合工具类，方便集合的操作。

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class CollectionsText {
    public static void main(String[] args) {
        //ArrayList集合不是线程安全的。
        List<String> list = new ArrayList<>();

        //变成线程安全的
        Collections.synchronizedList(list);

        //排序
        list.add("abc");
        list.add("def");
        list.add("abd");
        list.add("abe");

        Collections.sort(list);
        for (String s : list) {
            System.out.println(s);
        }

        List<wugui> wuguis = new ArrayList<>();
        wuguis.add(new wugui(100));
        wuguis.add(new wugui(800));
        wuguis.add(new wugui(50));

        //对List集合中元素排序，需要保证List集合中的元素实现了：Comparable接口
        Collections.sort(wuguis);

        for (wugui w : wuguis){
            System.out.println(w);
        }

    }
}

class wugui implements Comparable<wugui>{
    int age;

    public wugui(int age) {
        this.age = age;
    }

    @Override
    public int compareTo(wugui o) {
        return this.age - o.age;
    }

    @Override
    public String toString() {
        return "wugui{" +
                "age=" + age +
                '}';
    }
}
```

![image.png|575](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418144055169.png)


# 五.  Comparable与Comparator接口的区别

## 1.  自定义类型实现comparable接口

```java
import java.util.TreeSet;

public class TreeSetText {
    public static void main(String[] args) {
        Customer c1 = new Customer(32);
        Customer c2 = new Customer(20);
        Customer c3 = new Customer(30);
        Customer c4 = new Customer(25);

        TreeSet<Customer> customers = new TreeSet<>();
        customers.add(c1);
        customers.add(c2);
        customers.add(c3);
        customers.add(c4);

        for(Customer c : customers){
            System.out.println(c);
        }
    }
}

class Customer implements Comparable<Customer>{
    int age;

    public Customer(int age) {
        this.age = age;
    }

    //需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较！
    //k.comparaTo(t.key)
    //拿着参数k和集合中的每一个k进行比较，返回值可能是 >0、<0、=0
    @Override
    public int compareTo(Customer o) {
/*        int age1 = this.age;
        int age2 = o.age;
        if (age1 == age2){
            return 0;
        }else if (age1 > age2){
            return 1;
        }else if (age1 < age2){
            return -1;
        }*/
        return this.age - o.age;
    }

    @Override
    public String toString() {
        return "Customer{" +
                "age=" + age +
                '}';
    }
}
```

![image.png|500](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418144152852.png)


## 2.  Comparable与Comparator的比较

**Comparable 与Comparator 都是用来实现集合中元素的比较、排序的**


| Comparable                                                                                    | Comparator                                                                                                                                                                                                                                     |
| --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Java提供了只包含一个compareTo( )方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0,正数来表明已经存在的对象小于，等于，大于输入对象。 | Java 提供了包含 compare ( ) 和 equals ( ) 两个方法的 Comparator 接口。Compare () 方法用来给两个输入参数排序，返回负数, 0, 正数表明第一一个参数是小于，等于，大于第二个参数。Equals () 方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回 true。<br> |
| `Comparable`是在**集合内部**定义的方法实现的排序，接口的方法或在集合内实现 Comparable 接口的方法。                               | `Comparator`是在**集合外部**实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator                                                                                                                                                                                     |
| `Comparable`位于包`java.lang`下                                                                   | `Comparator`位于包`java.util`下                                                                                                                                                                                                                    |

- Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer，自己就可以完成比较大小操作，已经实现了 Comparable 接口）
	自定义的类要在加入 list 容器中后能够排序，可以实现 Comparable 接口，在用 Collections 类的 sort 方法排序时，如果不指定 Comparator，那么就以自然顺序排序，这里的自然顺序就是实现 Comparable 接口设定的排序方式。
	
- 而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。


> 比如：你想对整数采用**绝对值大小来排序**，Integer 是不符合要求的，你不需要去修改 Integer  
> 类（实际上你也不能这么做）去改变它的排序行为，只要使用一个实现了 **Comparator** 接口的对象来实现控制它的排序就行了。