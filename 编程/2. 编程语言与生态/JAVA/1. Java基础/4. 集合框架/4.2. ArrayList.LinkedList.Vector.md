
# 一. List接口

## 1. 接口的特点

list集合存储元素的特点：**有序可重复**

- 有序：List集合中的元素有下标。从0开始，以1递增
- 可重复：存储1，还可以再存储1

## 2. 常用方法

1. **在集合末尾添加元素：**`void add(Object element)`
2. **在指定下标添加元素：**`void add(int index , Object element)`
	> 这个方法使用不多，因为对于ArrayList集合来说效率较低。
3. **根据下标获取元素：**`Object get(int index)`
	> 因为有下标，所以List集合有自己比较特殊的遍历方式。

	**通过下标遍历**
	```java
	for (int i = 0; i < List.size() ; i++){
 	Object o = List.get(i);
 	System.out.println(o); 
 }
	```

4. **获取指定对象第一次出现处的索引（下标）：**`int indexof(Object o)`
5. **获取指定对象最后一次出现处的索引（下标）：**`int lastIndexOf(Object o)`
6. **删除指定下标位置的元素：**`Object remove(int index)`
7. **修改指定下标元素：**`Object set(int index,Object element)`

# 二. ArrayList集合

- ArrayList 集合底层采用了数组这种数据结构，底层是 Object 类型的数组 Object []

- ArrayList 集合是非线程安全的。

- 数组的优点：检索效率比较高。

- 数组的缺点：随机增删元素的效率比较低。（向数组末尾添加、删除元素、效率还是很高的）、数组无法存储大数据量（无法找到一块非常巨大的连续的内存空间。）

- 但是 ArrayList 集合是往数组末尾添加元素，效率不受影响。

```java
List list1 = new ArrayList();//默认初始化容量为10
List list2 = new ArrayList(20);//指定初始化容量
```

## 1. ArrayList集合初始化容量

ArrayList集合默认初始化容量为：**10**（**底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量为10**）

## 2. ArrayList集合扩容

源代码的 grow 方法中使用了位运算：`int newCapacity = oldCapacity + (oldCapacity >> 1);`

> 10 的二进制位：00001010
> 10 的二进制右移 1 位是：00000101【5】

**结论：一次扩容到原来的 1.5 倍**

> 建议给定一个预估计的初始化容量，减少数组的扩容次数，这是 ArrayList 集合比较重要的优化策略。


## 3. ArrayList集合的构造方法

**第一种方法：**

```java
List list1 = new ArrayList();
List list2 = new ArrayList(100);
```

**第二种方法：**

- 1、先创建一个HashSet集合
- 2、将HashSet集合转换为ArrayList集合: `List list3 = new ArrayList(c);`

```java
Collection c = new HashSet();
c.add(100);
c.add(200);
c.add(300);
c.add(400);

List list3 = new ArrayList(c);
```


# 三. LinkedList集合

**LinkedList集合没有初始化容量，且不需要扩容**

ListedList底层是一个**双向链表**：

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250418134325243.png)


1. **链表的优点**：

	> 由于链表上的元素在空间存储上**内存地址不连续**。  
	> 所以随机增删元素的时候**不会有大量元素位移**，因此随机增删元素的**效率较高**。（因为增删元素不涉及到大量元素位移）


**在以后的开发中，如果遇到随机增删集合中的元素的业务比较多时，建议使用LinkedList。**

2. **链表的缺点**：

	> 不能通过数学表达式计算被**查找元素的内存地址**，每一次查找都是从头结点开始遍历，直到找到为止。所以LinkList集合**检索/查找的效率较低**。
	

**查阅效率较低**，每一次查找某个元素的时候都需要从头结点开始往下遍历。


# 四. Vector集合

Vector集合底层调用了**数组**这种数据结构。

Vector集合是**线程安全**的。

Vector所有的方法都有**synchronize**关键字修饰所以**线程安全**，但是**效率较低**。现在保证线程安全有别的方案了，所以Vector用的较少

## 1. Vector集合的扩容

**Vector集合的初始化容量为10**

**扩容之后是原容量的2倍。**


# 五. 将线程不安全的ArrayList集合转换为线程安全的

使用集合工具类： `java.util.Collections`

注意：

- `java.util.Collection`是集合接口
- `java.util.Collections` 是集合工具类


```java
List myList = new ArrayList();//非线程安全

//变成线程安全的
Collections.syncjronizedList(myList);

myLoxt.add("111");
myLoxt.add("222");
myLoxt.add("333");
```
