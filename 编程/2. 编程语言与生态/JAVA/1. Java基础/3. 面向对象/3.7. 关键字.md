# 一. This 关键字

关于 java 语言当中的 this 关键字

- 1 this 是一个关键字，翻译为：这个
- 2 this 是一个引用，this 是一个变量，this 变量中保存了内存地址指向了自身，this 存储在 JVM 堆内存 java 对象内部。
- 3 创建 100 个 java 对象，每一个对象都有 this，也就是说有 100 个不同的 this
- 4 this 可以出现在“实例方法”中，this 指向当前正在执行这个动作的对象。（this 代表当前对象）
- 5 this 在大多数情况下都是可以省略不写的
- 6 this 不能使用带有 static 的方法中

```java
public class CustomerTest
{
	public static void main(String[] args){
		//创建Customer对象
		Customer c1 = new Customer();
		c1.name = "zhangsan";
		
		//c1购物
		c1.shopping();

		Customer c2 = new Customer();
		c2.name = "lisi";
		c2.shopping();

		//调用doSome方法（修饰符列表上有static）
		//采用"类名."的方式访问，显然这个方法在执行的时候不需要对象的参加
		Customer.doSome();

		//调用doOther方法 
		Customer.doOther();
	}
}
```

```java
public class Customer
{
	//姓名
	String name;
	
	//构造方法
	public Customer(){
	
	}
	
	//不带有static关键字的方法
	//顾客购物的行为
	//每一个顾客购物最终的结果是不一样的
	//所以购物这个行为是属于对象级别的行为
	//由于每一个对象在执行购物这个行为的时候最终结果不同，所以购物这个动作必须有对象的参与
	//重点：没有static关键字的方法被称为“实例方法”
	//重点：没有static关键字的变量被称为“实例变量”
	//注意：当一个行为/动作执行的过程中是需要对象参与的，那么这个方法一定要定义为“实例方法”，不要带static关键字
	public void shopping(){
		System.out.println(this.name + "在购物！");//完整写法
		System.out.println(name+"在购物！");//this可以省略不写
	}

	public static void doSome(){
		//这个执行过程中没有“当前对象”，因为带有static的方法是通过类名的方式访问的。
		//或者说这个"上下文"当中没有"当前对象",自然也不存在this(this代表的是当前正在执行的这个动作的对象)
		
		//以下程序为什么编译错误呢？
		//doSome方法调用不是对象去调用，是一个类名去调用，执行过程中没有“当前对象”。
		//name是一个"实例变量"。以下代码的含义是:访问当前对象的name。
		//System.out.println(name);
		
		//static方法调用不需要对象，直接使用类名，所以执行过程中没有当前对象，所以不能使用this
		//System.out.println(this);
	}

	public static void doOther(){
		//假设想访问name这个实例变量的话应该怎么做？
		//System.out.println(name); //编译报错
		
		//可以采用以下方案，但是以下方案，绝对不是访问当前对象的name
		//创建对象
		Customer c = new Customer();
		System.out.println(c.name);//这里访问的name是c引用指向对象的name
	}
}
```

**编译结果：**

![image.png|338](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250416152152102.png)


## 1. 实例方法必须有对象的存在

例：
```java
实例方法
public void doOther(){
	System.out.println("do other!");
}

run是实例方法，调用run方法的一定是有对象存在的。一定先创造一个对象才能调用run方法

public void run(){
	System.out.println("run !");
	
	doOther是一个实例方法，实例方法调用必须有对象的存在
	以下代码的含义就是：调用当前对象的doOther方法
	doOther();//this大部分情况下可以省略
	this.doOther();//完整写法
}
```

## 2. 最终结论 ：

- 在带有 static 的方法当中不能直接访问实例变量和实例方法。
- 因为实例变量和实例方法都需要对象的存在。
- 而 static 的方法当中是没有 this 的，也就是说当前对象不存在。
- 自然也是无法访问当前对象的实例变量和实例方法。

## 3. This. 什么时候不能省略？

```text
用来区分局部变量和实例变量的时候，“this.”不能省略。
```

```java
public class User(){
	private int id; //实例变量
	
}

public int setId(int id){
	this.id = id; // 等号前面的是实例变量，等号后面的是局部变量
}
```

## 4. This 可以使用在哪里？

- 1 实例方法中，代表当前对象【语法格式：this.】
- 2 构造方法中, 通过当前的构造方法调用其他的构造方法【语法格式：this（实参）;】

**重点记忆：this () 这种语法只能出现在构造函数第一行。**

## 5. 什么时候程序在运行的时候出现空指针异常呢 ？

- 空引用访问实例相关的数据，因为实例相关的数据就是对象相关的数据，这些数据在访问的时候必须有对象的参与，当空引用的时候，对象不存在，访问这些实例数据一定会出现空指针异常。

实例相关的数据包括：

- 实例变量【对象需要存在】
- 实例方法【对象需要存在】


# 二. Static 关键字

- 1 static：静态的
- 2 static修饰的方法是静态方法
- 3 static修饰的变量是静态变量
- 4 所有static修饰的元素都称为静态的，都可以使用`类名.`的方式访问，当然也可以采用`引用.`【但不建议】
- 5 static修饰的所有元素都是类级别的特征，和具体的对象无关

```java
public class Chinese(){
	//所有中国人这个类的对象国籍都一样，这种特征属于类级别的特征，
	//可以提升为整个模板的特征，可以在变量前添加static关键字修饰
	//静态变量，静态变量在类加载的时候初始化，不需要创建对象，内存就开辟了。
	//静态变量存储在方法区内存当中。
	static String country = "中国";
}

public class ChineseTest
{
	public static void main(String[] args){
		Chinese zhangsan = new Chinese();
		System.out.println(Chinese.country);
	}
}
```

## 1. 什么时候成员变量声明为实例变量呢 ？

- 所有对象都有这个属性，但是这个属性的值会随着这个对象的变化而变化【不同对象的这个属性具体的值不同】

## 2. 什么时候成员变量声明为静态变量呢 ？

- 所有对象都有这个属性，并且所有对象这个属性的值是一样的，建议定义为静态变量，节省内存的开销。

**静态变量在类加载的时候初始化，内存在方法区中开辟。访问的时候不需要创建对象，直接使用 `类名. 静态变量名` 的方式访问。**


所有静态的数据都是可以采用`类名.`, 也可以采用`引用.`，但是建议采用`类名.` 的方式访问。
采用`引用.` 的方式访问的时候，即使引用的是 null，也不会出现`空指针异常`，因为访问静态的数据不需要对象的存在。

## 3. 可以使用static关键字来定义“静态代码块”：

1、语法格式：

```java
static{
	java语句;
}
```

2、静态代码块在类加载时执行，并且只执行一次。

3、静态代码块在一个类中可以编写多个，并且遵循自上而下的顺序依次执行。·

4、静态代码块的作用是什么？怎么用？用在哪？什么时候用？

- 这当然和具体的需求有关，例如项目中要求在类加载的时候执行代码完成日志的记录。那么这段记录日志的代码就可以编写到静态代码当中，完成日志记录

- 静态代码块是 java 为程序员准备的一个特殊的时刻，这个特殊的时刻被称为类加载时刻。若希望在此刻执行一段特殊的程序，这段程序可以直接放到静态代码当中。

5、通常在静态代码块当中完成预备工作，先完成数据的准备工作，例如：初始化连接池，解析 XML 配置文件…

## 4. 方法什么时候定义为静态的 ？

```text
方法描述的是动作，当所有的对象执行这个动作的时候，最终产生影响是一样的。那么这个动作已经不再属于某一个对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作。
```

静态方法中无法直接访问实例变量和实例方法。

大多数方法都定义为实例方法，一般一个行为或者一个动作在发生的时候，都需要对象的参与。但是也有例外，例如：大多数“工具类”中的方法都是静态方法，因为工具就是方便编程，为了方便方法的调用，自然不需要 new 对象是最好的。


# 三. final关键字

关于 java 语言当中 final 关键字：
1、final 是一个关键字，表示最终的，不可变的

2、**final 修饰的类无法被继承**

3、**final 修饰的方法无法被覆盖**

4、**final 修饰的变量一旦被赋值之后，不可重新赋值【不可二次赋值】**

5、**final 修饰的实例变量，必须手动赋值，不能采用系统默认值 final 变量必须手动赋值，不能采用系统默认值**

```java
//final int age; //编译错误
final int age = 10;

或

final int num;

public FinalTest(){
	this.num = 200;
}
```

6、**final修饰的引用，一旦指向某个对象之后，不能在指向其他对象，那么被指向的对象无法被垃圾回收器回收。**

final修饰的引用虽然指向某个对象之后不能指向其他对象，但是所指向的对象内部的内存是可以被修改的。

```java
User u = new User(100);

u = new User(200);

final User user = new User(30);
//user = new User (50); //final修饰的引用，一旦指向某个对象之后，不能在指向其他对象，那么被指向的对象无法被垃圾回收器回收。

System.out.println(user.id);  //30
user.id = 50;//final修饰的引用虽然指向某个对象之后不能指向其他对象，但是所指向的对象内部的内存是可以被修改的。

System.out.println(user.id);  //50
```

7、**final 修饰的实例变量，一般和 static 联合使用，被称为变量**。

Final 修饰的实例变量是不可变的，这种变量一般和 static 联合使用，被称为常量。

常量定义的语法格式【常量名全部大写，每个单词之间使用下划线连接】
`Public static final 类型常量名 = 值`


# 四. super关键字

## 1. Super 的使用

`Super. 属性名`：【访问父类的属性】
`Super. 方法名（实参）`：【访问父类的方法】
`Super (实参)`：【调用父类的构造方法】

## 2. Super 应用
1、super 是一个关键字，全部小写
2、

- Super 能出现在实例方法中。

- Super 的语法是：super. 或 super ()

- Super 不能使用在静态方法中

- Super. 大部分情况下是可以省略的

- Super. 什么时候不可以省略？
	父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，super. 不可以省略。

- Super () 只能出现在构造方法的第一行，通过当前的构造方法去调用“父类”中的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。

3、super ()：
表示通过子类的构造方法调用父类的构造方法。
模拟现实世界中的这种场景：要想有儿子，需要先有父亲

4、当一个构造方法第一行：
既没有 this () 又没有 super () 的话，默认会有一个 super ()；表示通过当前子类的构造方法调用父类的无参数构造方法。所以必须保证父类的无参数构造方法是存在的。

5、注意：this () 和 super () 不能共存，他们都是只能出现在构造方法的第一行。

6、无论怎样，父类的构造方法是一定会执行的。

## 3. Super . 什么时候不能省略？

父中有，子中又有，如果想在子中访问“父的特征”，`super. `不能省略。

- `This. Name`：当前对象的 name 属性
-  `Super. Name`：当前对象的父类型特征中的 name 属性
