
**API**（application program interface）:应用程序编程接口  
整个JDK的类库就是一个javase的API。  
每一个API都会配置一套API帮助文档。

# 一. Object类中的toString方法

## 1.  toString源代码：

```java
public String toString() {
	return this.getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

源代码上的toString() 方法的默认实现是：  
`类名@对象的内存地址转换为十六进制的形式`

## 2. toString()方法的作用

**通过调用这个方法可以将一个“java对象”转换成“字符串表示形式”**

## 3. 所有子类都要去重写toString()方法，更简洁

```java
public class Test01{
    public static void main(String[] args){
        MyTime t1 = new MyTime(1970,1,1);
        System.out.println(t1.toString());
    }
}

class MyTime{
    int year;
    int month;
    int day;

    public MyTime(){
    }

    public MyTime(int year,int month,int day){
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public String toString(){
        return this.year + "年" + this.month + "月" + this.day + "日";
    }
```

![image.png](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/20250416162917156.png)


# 二. Object类中的equals方法

## 1. equals方法的源代码

```java
public boolean equals(Object obj){
	return (this==obj);
}
```

## 2. equals的作用

在编程过程中，通过equals方法来判断两个对象是否相等。

## 3. equals判断是否够用？

在Object类中的equals方法当中，默认采用的是“= =”判断两个java对象是否相等，而“= =”判断的是两个java对象的内存地址，我们应该判断的是两个java对象的内容是否相等。所以需要子类重写equals。

```java
public class Test1{
    public static void main(String[] args){
        MyTime t1 = new MyTime(1970,1,1);
        MyTime t2 = new MyTime(1970,1,1);
        boolean flag = t1.equals(t2);
        System.out.println(flag);
    }
}

class MyTime{
    int year;
    int month;
    int day;

    public MyTime(){
    }

    public MyTime(int year,int month,int day){
        this.year = year;
        this.month = month;
        this.day = day;
    }
    public boolean equals(Object obj){
	if(obj == null){
		return false;
	}

	if(!(obj instanceof MyTime)){
		return false;
	}
	//如果this和obj保存的内存地址相同，没必要比较了，直接返回true。
	//内存地址相同的时候指向内存的对象肯定是同一个
	if(this == obj){
		return true;
	}

	MyTime t =(MyTime)obj;
	if(this.year == t.year && this.month == t.month && this.day == t.daay){
		return true;
	}
}
```


## 4. 判断两个java对象是否相等，不能使用“ = = ”，因为“= =”比较的是两个对象的内存地址

```java
MyTime t1 = new MyTime(1970,1,1);
MyTime t2 = new MyTime(1970,1,1);
System.out.println(t1 == t2);
```

```
==：这里判断的是t1保存的对象和t2保存的对象内存地址是否相等
```

## 5. java语言中的字符串String有没有重写toString方法，有没有equals方法

```java
String s1 = "hello";
String s2 = "abc";
//实际上String也是一个类，不属于基本数据类型
//既然String是一个类，那么一定存在构造方法

String s3 = new String("Test1");
String s4 = new String("Test1");
//new了两次，两个对象地址，s3保存的内存地址和s4保存的内存地址不同
//  ==判断的是内存地址，不是内容。
System.ou.println(s3 == s4);//结果为false
```

**怎样比较两个字符串呢？**  
必须调用equals方法，String类已经重写equals方法

```java
System.out.println(s3.equals(s4));//true
```

总结：  
1、String类已经重写了equals方法，比较两个字符串不能使用 == ，必须使用equals，equals是通用的。  
2、String类已经重写了toString方法。

## 6.  Java中基本数据类型比较是否相等用 ==

**Java中所有的引用数据类型统一使用equals方法来判断是否相等。**

判断字符串是否相等，最好调用字符串对象的equals方法。

## 7. 重写Object类的equals方法

```java
public boolean equals(Object obj){
	if(obj==null || !(obj instanceof 类名))  
	return false;
	if(this == obj)
	return true;
	类名  引用名 = (类名)obj;
	if(判断条件：字符串不能用==){
		return true;
	}
	return false;
}
```

## 8. equals方法重写要彻底


# 三. Object类中的方法：finalize

## 1. 关于Object类中的源代码：

`projected void finalize() throws Throwable { }`

## 2. finalize()方法只有一个方法体，里面没有代码，而且这个方法是projected修饰的。

## 3. 这个方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法。

## 4. finalize()方法的执行时机

当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用finalize()方法。

## 5. finalize()方法实际上是SUN公司为java程序员准备的一个时机，垃圾销毁时机。如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize()方法中

## 6. 静态代码块的作用是什么？

```java
static {
...
}
```

静态代码块在类加载的时刻执行，并且只执行一次。  
这是SUN准备的类加载时机。

finalize()方法同样也是SUN为程序员准备的一个时机。这个时机是垃圾回收时机。

## 7. 提示：java中的垃圾回收器不是轻易启动的

垃圾太少，或者时间没到，种种条件下，有可能启动，也有可能不启动，


# 四. Object类中的方法：hashCode

**在 Object 中的 hashCode 方法是怎样的？**

`Public native int hashCode ()`

这个方法不是抽象方法，带有 native 关键字，底层调用 C++程序。

**HashCode () 方法返回的是哈希码：**

实际上就是一个 java 对象的内存地址，经过哈希算法，得出一个值。所以 hashCode () 方法的执行结果可以等同看做一个 java 对象的**内存地址**。






