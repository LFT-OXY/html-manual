## Java主导型（推荐）

**架构设计**

```plain
Vue前端 → SpringBoot后端 → Python微服务（可选增强）
```

**技术选型**

- **Java后端**：Apache POI + PDFBox + Tess4J
- **Python服务**：FastAPI + PaddleOCR（专门处理复杂OCR）
- **Vue前端**：文件上传 + 进度显示 + 结果展示

**优势**

- 主要逻辑在Java中，与现有RuoYi架构完美融合
- Python只负责AI增强功能，降低系统复杂度
- 易于维护和部署



**当前OCR只识别文字，完全丢失了表格的行列结构**。扫描PDF中的表格被当作普通文字处理，无法在前端正确展示。

## 技术难点

扫描PDF的表格识别比文本PDF困难得多：

- **表格检测**：需要识别图像中的表格区域
- **结构识别**：识别表格的行列边界
- **单元格定位**：确定每个单元格的位置
- **内容提取**：对每个单元格进行OCR

## 可行方案对比

### 方案1：基于OpenCV的表格线检测

**优点：**

- 可以准确检测表格边框线
- 适用于有明显边框的表格
- 可以精确定位单元格

**缺点：**

- 需要引入OpenCV依赖（体积大）
- 对无边框表格效果差
- 实现复杂度高

**实现思路：**

```java
1. 使用OpenCV检测水平线和垂直线
2. 找到线的交点，确定单元格边界
3. 对每个单元格区域进行OCR
4. 构建TableData对象
```

### 方案2：使用Tesseract的TSV输出

**优点：**

- 无需额外依赖
- Tesseract自带表格识别能力
- 可以获取文字的位置坐标
- 实现相对简单

**缺点：**

- 识别准确度取决于Tesseract
- 对复杂表格可能效果不佳

**实现思路：**

```java
1. 使用Tesseract的TSV输出格式
2. TSV包含每个单词的坐标信息
3. 根据坐标分析文字的行列关系
4. 重建表格结构
```

#### 实施方案

##### Tesseract TSV输出格式说明

TSV（Tab-Separated Values）输出包含每个识别单词的详细信息：

```plain
level  page_num  block_num  par_num  line_num  word_num  left  top  width  height  conf  text
1      1         0          0        0         0         0     0    1000   1500    -1    
2      1         1          0        0         0         100   50   800    100     -1    
3      1         1          1        0        0         100   50   800    100     -1    
4      1         1          1        1        0         100   50   800    20      -1    
5      1         1          1        1        1         100   50   100    20      95    "姓名"
```

关键字段：

- **left, top**: 文字左上角坐标
- **width, height**: 文字区域尺寸
- **line_num**: 行号（用于判断是否同一行）
- **block_num**: 块号（用于分组）
- **text**: 识别的文字
- **conf**: 置信度

#### 核心算法

1. **获取TSV数据**：使用Tesseract的`createDocuments()`方法
2. **解析TSV**：提取文字坐标和内容
3. **智能分组**：

- 根据Y坐标（top）分行
- 根据X坐标（left）分列
- 允许一定的容差（考虑文字对齐偏差）

1. **构建表格**：将分组的文字组装成TableData



### 方案3：结合图像预处理+智能识别

**优点：**

- 对表格进行预处理，提高识别率
- 可以处理有边框和无边框表格
- 可以自动检测表格区域

**缺点：**

- 需要一定的图像处理知识
- 可能需要多次调试参数

**实现思路：**

```java
1. 图像预处理：二值化、去噪、增强边框
2. 使用Tesseract的hOCR或TSV输出
3. 分析文字坐标，智能分组
4. 根据空白区域判断行列边界
5. 构建表格结构
```

### 方案4：使用PaddleOCR表格识别

**优点：**

- 专门的表格识别模型
- 识别准确度最高
- 支持复杂表格

**缺点：**

- 需要Python环境或API调用
- 部署复杂
- 可能需要额外成本



### 方案 5：使用 olmOCR

地址： https://github.com/allenai/olmocr

一个用于将 PDF 和其他基于图像的文档格式转换为清晰、易读的纯文本格式的工具包。

试试在线演示：https://olmocr.allenai.org/

特征：

- 将 PDF、PNG 和 JPEG 文档转换为简洁的 Markdown 格式。
- 支持公式、表格、手写输入和复杂格式
- 自动移除页眉和页脚
- 即使存在图表、多栏布局和插页，也能将其转换为具有自然阅读顺序的文本。
- 效率高，每百万页转换成本低于 200 美元
- （基于 7B 参数 VLM，因此需要 GPU）

#### 安装

要求：

- 最新款NVIDIA显卡（已在RTX 4090、L40S、A100、H100上测试），至少配备15GB显存。
- 30GB 可用磁盘空间

您需要安装 poppler-utils 和其他字体才能渲染 PDF 图像。



搭建一个 conda 环境并安装 olmocr。运行 olmOCR 所需的依赖项很难在现有的 Python 环境中安装，因此请务必创建一个全新的 Python 环境进行安装。









### 大模型

#### 1.网页版：

##### 1.1 flowin

https://flowin.cn/doc



#### 2.本地部署：

![img](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/1763444623316-fc23b7e4-a9ed-4201-a659-be29300b7bc6.png)



#### 3.可 api 调用：

##### 3.1 MinerU

![img](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/1763444640092-04e76969-cabb-4760-aa90-1f2237a6ec88.png)

MinerU地址：https://mineru.net/

实现展示：

![img](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/1763453033832-79f1f918-4a13-42f8-b6df-6a3f4d29e4e4.png)



##### 3.2 OCRmyPDF

![img](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/1763444705456-a158a536-12ed-43f1-8051-b84c7bff0cf8.png)

OCRmyPDF地址：https://github.com/ocrmypdf/OCRmyPDF

OCRmyPDF 使用 Tesseract 进行 OCR 识别，并依赖于其语言包。OCRmyPDF 支持 Tesseract 4.1.1 及更高版本。它会自动使用`PATH`环境变量中第一个找到的 Tesseract 版本。

**要求**

除了所需的 Python 版本外，OCRmyPDF 还需要外部安装 Ghostscript 和 Tesseract OCR 程序。OCRmyPDF 完全由 Python 编写，几乎可以在所有操作系统上运行：Linux、macOS、Windows 和 FreeBSD。

其实 java 也是用的Tesseract 这套包。



##### 3.3 Nanonets-OCR-sNanonets

![img](https://picgo-q1uill.oss-cn-chengdu.aliyuncs.com/img-for-typora/1763444671297-9b9ac6ba-f8fc-4beb-950e-cfc441fdf78c.png)